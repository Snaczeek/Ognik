[{"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\index.js":"1","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\App.js":"2","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Header.js":"3","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\AuthContext.js":"4","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\utils\\ProtectedRoute.js":"5","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\MainApp.js":"6","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\HomePage.js":"7","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\LoginPage.js":"8","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\RegisterPage.js":"9","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ChannelListContainer.js":"10","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MainContainer.js":"11","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\FriendContext.js":"12","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendList.js":"13","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Sidebar.js":"14","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendRequestListContainer.js":"15","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\AddFriendContainer.js":"16","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MessageContainer.js":"17","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ConControls.js":"18","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ConTest.js":"19"},{"size":250,"mtime":1689102107715,"results":"20","hashOfConfig":"21"},{"size":1029,"mtime":1697019444919,"results":"22","hashOfConfig":"21"},{"size":1004,"mtime":1690304206603,"results":"23","hashOfConfig":"21"},{"size":5936,"mtime":1720737498236,"results":"24","hashOfConfig":"21"},{"size":412,"mtime":1689100876600,"results":"25","hashOfConfig":"21"},{"size":545,"mtime":1689096982239,"results":"26","hashOfConfig":"21"},{"size":2036,"mtime":1722356161296,"results":"27","hashOfConfig":"21"},{"size":1378,"mtime":1690365751729,"results":"28","hashOfConfig":"21"},{"size":5096,"mtime":1697028759663,"results":"29","hashOfConfig":"21"},{"size":510,"mtime":1690391685414,"results":"30","hashOfConfig":"21"},{"size":874,"mtime":1720033697658,"results":"31","hashOfConfig":"21"},{"size":1724,"mtime":1697028366727,"results":"32","hashOfConfig":"21"},{"size":813,"mtime":1720007710864,"results":"33","hashOfConfig":"21"},{"size":2578,"mtime":1719948631476,"results":"34","hashOfConfig":"21"},{"size":3012,"mtime":1720037757427,"results":"35","hashOfConfig":"21"},{"size":3753,"mtime":1720114099742,"results":"36","hashOfConfig":"21"},{"size":12615,"mtime":1720791032580,"results":"37","hashOfConfig":"21"},{"size":16993,"mtime":1720380034846,"results":"38","hashOfConfig":"21"},{"size":9531,"mtime":1720382100056,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1m3h4dg",{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46"},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54"},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71"},{"filePath":"72","messages":"73","suppressedMessages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75"},{"filePath":"76","messages":"77","suppressedMessages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},{"filePath":"80","messages":"81","suppressedMessages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83"},{"filePath":"84","messages":"85","suppressedMessages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87"},{"filePath":"88","messages":"89","suppressedMessages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91"},{"filePath":"92","messages":"93","suppressedMessages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95"},{"filePath":"96","messages":"97","suppressedMessages":"98","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99"},{"filePath":"100","messages":"101","suppressedMessages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"103"},{"filePath":"104","messages":"105","suppressedMessages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107"},{"filePath":"108","messages":"109","suppressedMessages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111"},"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\index.js",[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\App.js",["112","113"],[],"import './App.css';\r\nimport Header from './components/Header';\r\nimport AuthContext, { AuthProvider } from './context/AuthContext';\r\n\r\nimport { Routes, Route, HashRouter  as Router } from 'react-router-dom'\r\nimport ProtectedRoute from './utils/ProtectedRoute'\r\n\r\nimport HomePage from './pages/HomePage';\r\nimport LoginPage from './pages/LoginPage';\r\nimport MainApp from './pages/MainApp';\r\nimport RegisterPage from './pages/RegisterPage';\r\n\r\n\r\nfunction App() {\r\n  // let {user} = useContext(AuthContext)\r\n\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Router >\r\n        <AuthProvider>\r\n          <Routes>\r\n            <Route element={<HomePage />} path=\"/\"/>\r\n            <Route element={<LoginPage />} path=\"/login\"/>\r\n            <Route element={<RegisterPage />} path=\"/register\" />\r\n            <Route element={<ProtectedRoute />}>\r\n              <Route path='/test/*' element={<MainApp />} />\r\n            </Route>\r\n          </Routes>\r\n        </AuthProvider>\r\n      </Router>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Header.js",["114"],[],"import React, {useContext} from 'react'\r\nimport { Link } from 'react-router-dom'\r\nimport AuthContext from '../context/AuthContext'\r\n\r\nconst Header = () => {\r\n  let {user, logoutUser} = useContext(AuthContext)\r\n  return (\r\n    <div className='bg-neutral-900 flex h-auto pl-28 pr-28 pt-5 pb-5 text-white'>\r\n        <Link to=\"/\" className='pl-3 pr-3 pt-1 hover:underline'>Ognik</Link>\r\n        {/* <a className='pl-3 pr-3 pt-1'>About</a> */}\r\n        <a className='pl-3 pr-3 pt-1 hover:underline' href='https://github.com/Snaczeek/Ognik'>Github</a>\r\n        {user ? (\r\n          <div className='ml-auto'><button className='header-button'><Link to=\"/test/friends\">Open ognik</Link></button></div>\r\n          ): (\r\n            <div className='ml-auto'><Link to=\"/login\"><button className='header-button'>Login</button></Link> </div>\r\n            )}\r\n\r\n        {/* {user && <h1>Hello {user.username}</h1>} */}\r\n        {/* <Link to=\"/register\">Register</Link> */}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Header\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\AuthContext.js",["115"],[],"import { createContext, useState, useEffect } from 'react';\r\nimport jwt_decode from \"jwt-decode\";\r\nimport { useNavigate } from 'react-router-dom'\r\nimport { w3cwebsocket as W3CWebSocket} from 'websocket';\r\nimport configData from '../config.json'\r\n\r\nconst AuthContext = createContext();\r\n\r\nexport default AuthContext\r\n\r\nexport const AuthProvider = ({children}) => {\r\n    \r\n    // Checking if user has token in browser storage\r\n    // if so then, parsing value into json format\r\n    let [authToken, setAuthTokens] = useState(() => localStorage.getItem('authToken') ? JSON.parse(localStorage.getItem('authToken')) : null)\r\n    // decoding jwt token into useable block\r\n    let [user, setUser] = useState(() => localStorage.getItem('authToken') ? jwt_decode(localStorage.getItem('authToken')) : null)\r\n    \r\n    let [loading, setLoading] = useState(true)\r\n    // https://ognik-backend.duckdns.org/\r\n    let url = configData.WS_URL+`ws/socket-server/`\r\n    let [WebSocket, setWebSocket] = useState(() => localStorage.getItem('authToken') ? new W3CWebSocket(url + \"?token=\" + String(authToken.access)) : null)\r\n    \r\n    const navigate = useNavigate()\r\n    \r\n    // Must be in try block \r\n    // Because on first load Websocket ist set to NULL so .onclose property doesn't exist \r\n    try{\r\n        // If Websocket connection was interruptedly closed\r\n        // Refresh page \r\n        WebSocket.onclose = () => {\r\n            console.log(\"AuthContext: Websocket Closed\")\r\n            // window.location.reload();\r\n        }\r\n    }catch(e){\r\n    \r\n    }\r\n    \r\n    // login function\r\n    let loginUser = async (e ) => {\r\n        try{\r\n            e.preventDefault()\r\n            // fetching credentials to django backend\r\n           \r\n                let response = await fetch(configData.BACKEND_URL+'users/token/', {\r\n                    method: 'POST',\r\n                    headers:{\r\n                        'Content-Type':'application/json'\r\n                    },\r\n                    body:JSON.stringify({'username':e.target.username.value, 'password':e.target.password.value})\r\n                })\r\n                let data = await response.json()\r\n            \r\n            // if response form django is positive \r\n            // saving token data to browser storage (at this point user is logged)\r\n            if(response.status === 200)\r\n            {\r\n                setAuthTokens(data)\r\n                setUser(jwt_decode(data.access))\r\n                if (!WebSocket){\r\n                    setWebSocket(new W3CWebSocket(url + \"?token=\" + String(data.access)))\r\n                }\r\n                localStorage.setItem('authToken', JSON.stringify(data))\r\n                navigate('/test/friends')  \r\n                window.location.reload()             \r\n            }\r\n            else\r\n            {\r\n                document.getElementsByClassName('login-error-message')[0].innerHTML = 'Incorrect username or password'\r\n                document.getElementById(\"login-username\").style.borderStyle = \"solid\"   \r\n                document.getElementById(\"login-username\").style.borderColor = \"rgb(185, 28, 28)\"   \r\n                document.getElementById(\"login-username\").style.borderWidth = '3px' \r\n                document.getElementById(\"login-password\").style.borderColor = \"rgb(185, 28, 28)\"   \r\n                document.getElementById(\"login-password\").style.borderWidth = '3px' \r\n                document.getElementById(\"login-password\").style.borderStyle = \"solid\"   \r\n            }\r\n        }catch(e){\r\n            alert('Backend is not available')\r\n        }\r\n    }\r\n    \r\n    // logout function\r\n    let logoutUser = () => {\r\n        setAuthTokens(null)\r\n        setUser(null)\r\n        \r\n        // clearing users web storage\r\n        localStorage.removeItem('authToken')\r\n        navigate('/')\r\n    }\r\n    \r\n    // updating access token\r\n    let updateToken = async () => {\r\n        try{\r\n\r\n            // fetching refresh token to django backend\r\n            let response = await fetch(configData.BACKEND_URL+'users/token/refresh/', {\r\n                method: 'POST',\r\n                headers:{\r\n                    'Content-Type':'application/json'\r\n                },\r\n                // if refresh token exist, send it\r\n                // if not, send null\r\n                body:JSON.stringify({'refresh': authToken?.refresh})\r\n            })\r\n            let data = await response.json()\r\n    \r\n            // saving new tokens\r\n            if (response.status === 200){\r\n                setAuthTokens(data)\r\n                setUser(jwt_decode(data.access))\r\n                localStorage.setItem('authToken', JSON.stringify(data))\r\n            }else\r\n            {\r\n                logoutUser()\r\n            }\r\n            \r\n            if(loading){\r\n                setLoading(false)\r\n            }\r\n        }\r\n        catch(e){\r\n            setLoading(false)\r\n            alert('Backend is not available')\r\n        }\r\n    }\r\n    \r\n    // context data for provider\r\n    let contextData = {\r\n        user:user,\r\n        authToken:authToken,\r\n        loginUser:loginUser,\r\n        logoutUser: logoutUser,\r\n        WebSocket:WebSocket,\r\n    }\r\n    \r\n    useEffect(() => {\r\n   \r\n        \r\n        // before children are rendered \r\n        // update token\r\n        if(loading){\r\n            updateToken()\r\n        }\r\n    \r\n\r\n        // run updateToken() every 4 minutes\r\n        let s4Minutes = 1000 * 60 * 4\r\n        let interval = setInterval(() => {\r\n            if(authToken){\r\n                updateToken()\r\n            }\r\n        }, s4Minutes)\r\n        return ()=> clearInterval(interval)\r\n        \r\n    }, [authToken, loading, WebSocket])\r\n    \r\n    // returnig contex data for children\r\n    return (\r\n        <AuthContext.Provider value={contextData}>\r\n        {/* render children after loading is done */}\r\n        {loading? null : children}\r\n        {/* {children} */}\r\n    </AuthContext.Provider>\r\n    );\r\n}","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\utils\\ProtectedRoute.js",[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\MainApp.js",["116","117","118","119","120"],[],"import React, {useState, useEffect, useContext} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\nimport FriendContext, {FriendProvider} from '../context/FriendContext'\r\nimport ChannelListContainer from '../components/ChannelListContainer'\r\nimport MainContainer from '../components/MainContainer'\r\n\r\nconst MainApp = () => {\r\n \r\n  return (\r\n    <div className='MainApp'>\r\n      <FriendProvider>\r\n          <ChannelListContainer />\r\n          <MainContainer />\r\n      </FriendProvider>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default MainApp\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\HomePage.js",[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\LoginPage.js",[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\RegisterPage.js",["121","122","123","124"],[],"import React, {useContext} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\nimport configData from '../config.json'\r\n\r\nconst RegisterPage = () => {\r\n    let {loginUser} = useContext(AuthContext)\r\n    let register = async (e) => {\r\n        e.preventDefault()\r\n        // Getting input html objects\r\n        let email = e.target.email\r\n        let nickname = e.target.username\r\n        let password = e.target.password\r\n        let confirmPassword = e.target.confirmPassword\r\n        \r\n        // Getting html error objects\r\n        const emailError = document.getElementById(\"error-email-input\")\r\n        const usernameError = document.getElementById(\"error-username-input\")\r\n        const passwordError = document.getElementById(\"error-password-input\")\r\n        const confirmPasswordError = document.getElementById(\"error-confirm-password-input\")\r\n\r\n        const formData = {\r\n            username: e.target.username.value,\r\n            password: e.target.password.value,\r\n            email: e.target.email.value,\r\n        }\r\n\r\n        // Reseting error \r\n        email.style.borderStyle = \"none\"\r\n        nickname.style.borderStyle = \"none\"\r\n        password.style.borderStyle = \"none\"\r\n        confirmPassword.style.borderStyle = \"none\"\r\n\r\n        emailError.innerHTML = \"\"\r\n        usernameError.innerHTML = \"\"\r\n        confirmPasswordError.innerHTML = \"\"\r\n\r\n        // Regex for checking email\r\n        const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n        \r\n\r\n        // Incorrect email\r\n        if (!regex.test(email.value))\r\n        {\r\n            alert(\"incorrect email\")\r\n            email.style.borderStyle = \"solid\"\r\n            email.style.borderColor = \"red\"\r\n            emailError.innerHTML = \"Incorrect email\"\r\n            return\r\n        }\r\n\r\n        // Incorrect password confirm\r\n        if (password.value != confirmPassword.value)\r\n        {\r\n            alert(\"confirm password doesn't match up\")\r\n            password.style.borderStyle = \"solid\"\r\n            confirmPassword.style.borderStyle = \"solid\"\r\n            password.style.borderColor = \"red\"\r\n            confirmPassword.style.borderColor = \"red\"\r\n            confirmPasswordError.innerHTML = \"Passwords doesn't match\"\r\n            return\r\n        }\r\n\r\n        let response = await fetch(configData.BACKEND_URL+'users/register', {\r\n            method: \"POST\",\r\n            headers:{\r\n                'Content-Type':'application/json'\r\n            },\r\n            body: JSON.stringify(formData)\r\n        })\r\n        let data = await response.json()\r\n\r\n        // Incorrect Username\r\n        if (data.error == \"Username already exists\")\r\n        {\r\n            alert(\"Username is already taken\")\r\n            nickname.style.borderStyle = \"solid\"\r\n            nickname.style.borderColor = \"red\"\r\n            usernameError.innerHTML = \"Username is already taken\"\r\n            return\r\n        }\r\n\r\n        if (data.error == \"Username is too long\")\r\n        {\r\n            nickname.style.borderStyle = \"solid\"\r\n            nickname.style.borderColor = \"red\"\r\n            usernameError.innerHTML = \"Username is to long\"\r\n            return\r\n        }\r\n        loginUser(e)\r\n    }\r\n\r\n  return (\r\n    <div className='login-bg'>\r\n        <div className='register-island'>\r\n            <form onSubmit={register} autoComplete='off' id='register-form' className='flex flex-col w-full'>\r\n                <p className='text-center font-bold text-white text-3xl'>Register</p>\r\n                <div className='mb-3'>\r\n                    <label className='login-text'>E-mail</label> <br/>\r\n                    <input type=\"text\" id='register-email' name='email' className='login-input' placeholder='e-mail'/> <br/>\r\n                    <p id='error-email-input' className='login-error-message'></p>\r\n                </div>\r\n\r\n                <div className='mb-3'> \r\n                    <label className='login-text'>Username</label> <br/>\r\n                    <input type=\"text\" id='register-nickname' name='username' className='login-input' placeholder='username'/> <br/>\r\n                    <p id='error-username-input' className='login-error-message'></p>\r\n                </div>\r\n\r\n                <div className='mb-3'>\r\n                    <label className='login-text'>Password</label> <br/>\r\n                    <input type=\"password\" id='register-password' name='password' className='login-input' placeholder='password'/> <br/>\r\n                    <p id='error-password-input' className='login-error-message'></p>\r\n                </div>\r\n\r\n                <div className='mb-3'>\r\n                    <label className='login-text'>Confirm Password</label> <br/>\r\n                    <input type=\"password\" id='confirm-register-password' name='confirmPassword' className='login-input' placeholder='confirm password'/> <br/>\r\n                    <p id='error-confirm-password-input' className='login-error-message'></p>\r\n                </div>\r\n\r\n                <button className='register-button'>SIGN UP</button>\r\n            </form>   \r\n        </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default RegisterPage","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ChannelListContainer.js",["125"],[],"import React from 'react'\r\nimport Sidebar from './Sidebar'\r\nimport FriendList from './FriendList'\r\nimport MainContainer from '../components/MainContainer'\r\n\r\nimport { Routes, Route } from 'react-router-dom'\r\n\r\n\r\nexport const ChannelListContainer = () => {\r\n  return (\r\n    <div className=\"inline-flex w-80 h-screen  bg-gray-800\">\r\n        <Sidebar />\r\n        <Routes>\r\n          <Route path=\"/friends/*\" element={<FriendList />} />\r\n        </Routes>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default ChannelListContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MainContainer.js",["126","127","128"],[],"import React, {useContext, useState, useEffect} from 'react'\r\nimport MessageContainer from './MessageContainer'\r\nimport AddFriendContainer from './AddFriendContainer'\r\nimport FriendRequestListContainer from './FriendRequestListContainer'\r\n\r\nimport { Routes, Route } from 'react-router-dom'\r\nimport AuthContext from '../context/AuthContext'\r\nimport FriendContext from '../context/FriendContext'\r\nconst MainContainer = () => {\r\n  let {wsdata} = useContext(FriendContext)\r\n\r\n  return (\r\n    <div className='w-full bg-gray-700'>\r\n      <Routes>\r\n        <Route path=\"/friends/mcon/:username\" element={<MessageContainer asd={wsdata}/>} />\r\n        <Route path=\"/friends/addFriend\" element={<AddFriendContainer />} />\r\n        <Route path=\"/friends/friendRequestList\" element={<FriendRequestListContainer />} />\r\n      </Routes>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default MainContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\FriendContext.js",["129"],[],"import React from 'react'\r\nimport { createContext, useState, useEffect, useContext } from 'react';\r\nimport AuthContext from '../context/AuthContext'\r\nimport configData from '../config.json'\r\n\r\nconst FriendContext = createContext();\r\n\r\nexport default FriendContext\r\n\r\nexport const FriendProvider = ({children}) => {\r\n    let [friends, setFriends] = useState([null])\r\n    let {authToken, WebSocket} = useContext(AuthContext) \r\n    let [wsdata, setWsdata] = useState(null)  \r\n\r\n    WebSocket.onmessage = (e) => {\r\n        let data = JSON.parse(e.data)\r\n        console.log(data)\r\n        setWsdata(data)\r\n        // console.log(wsdata)\r\n        if(data.type === \"friendRequest\")\r\n        {\r\n            getFriends()\r\n            window.location.reload()\r\n        }\r\n    }\r\n\r\n    let getFriends = async () =>{\r\n        let response = await fetch(configData.BACKEND_URL+'users/friends/', {\r\n            method: \"GET\",\r\n            headers:{\r\n                'Content-Type':'application/json',\r\n                'Authorization':'Bearer ' + String(authToken.access)\r\n            }\r\n        })\r\n\r\n        let data = await response.json()\r\n        let new_data = []\r\n        \r\n        // pushing only username's to new array\r\n        for (let i = 0; i < data[0].friends.length; i++) {\r\n            // console.log(\"test: \" + data[0].friends[i].username + \" \" + i);\r\n            new_data.push(data[0].friends[i].username)\r\n        }\r\n        setFriends(new_data)\r\n    }\r\n\r\n    useEffect(() => {\r\n        getFriends()\r\n    }, [])\r\n\r\n    let contextData = {\r\n        friends:friends,\r\n        wsdata:wsdata\r\n    }\r\n\r\n  return (\r\n    <FriendContext.Provider value={contextData}>\r\n        {children}\r\n    </FriendContext.Provider>\r\n  )\r\n}\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendList.js",["130","131","132"],[],"import React, {useState, useEffect, useContext, createContext} from 'react'\r\nimport FriendContext from '../context/FriendContext'\r\nimport { Link } from 'react-router-dom';\r\n\r\nconst FriendListContext = createContext();\r\n\r\nexport const FriendList = () => {\r\n\r\n    let {friends} = useContext(FriendContext)\r\n    let i = 0\r\n\r\n  return (\r\n    <div className='w-[75%] flex flex-col h-screen'>\r\n      <Link to={\"./addFriend\"}><div className='add-friend-button'>Add Friend</div></Link>\r\n      <div className='text-center p-4 text-gray-500'>Friends list</div>\r\n      <div className='flex-grow overflow-y-auto scrollbar'>\r\n        {friends.map(f => (\r\n            <Link to={\"./mcon/\"+f} ><div key={i++}className='friend-container'>{f}</div></Link>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default FriendList","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Sidebar.js",["133"],[],"import React, { useContext, useEffect } from \"react\";\r\nimport AuthContext from \"../context/AuthContext\";\r\nimport { AiFillFire, AiOutlineUserAdd, AiOutlineLogout } from \"react-icons/ai\";\r\nimport configData from \"../config.json\"\r\n\r\nimport { Link } from 'react-router-dom';\r\n\r\n\r\nexport const Sidebar = () => {\r\n\r\n    let { WebSocket, logoutUser, authToken} = useContext(AuthContext)\r\n\r\n    WebSocket.onmessage = (e) => {\r\n        let data = JSON.parse(e.data)\r\n        // console.log(data)\r\n        if(data.type === \"friendRequest\")\r\n        {\r\n            getFriendRequest()\r\n            window.location.reload()\r\n        }\r\n    }\r\n\r\n    let getFriendRequest = async () => {\r\n        let response = await fetch(configData.BACKEND_URL+'users/friendrequest/getFriendRequest', {\r\n          method: 'GET',\r\n          headers:{\r\n            'Content-Type':'application/json',\r\n            'Authorization':'Bearer ' + String(authToken.access)\r\n          },\r\n        })\r\n        let data = await response.json()\r\n        // console.log(data.length)\r\n        if (data.length !== 0)\r\n        {\r\n            // console.log(\"Debug Show Red Dot\")\r\n            document.getElementById(\"red_circle\").removeAttribute(\"hidden\");\r\n        }\r\n        else\r\n        {\r\n            // console.log(\"empty\")\r\n            document.getElementById(\"red_circle\").setAttribute(\"hidden\", \"\")\r\n        }\r\n      }\r\n\r\n      useEffect(() => {\r\n        getFriendRequest()\r\n      }, [])\r\n\r\n      let exit = async () => {\r\n        logoutUser()\r\n        // const delay = ms => new Promise(\r\n        //     resolve => setTimeout(resolve, ms)\r\n        // );\r\n        // await delay(1000)\r\n        // window.location.reload()\r\n        \r\n      }\r\n\r\n    return (\r\n        <div className=\"sidebar\">\r\n            <div className=\"sidebar-icon group\">\r\n                <Link to=\"./friends\"><AiFillFire size=\"48\"/></Link>\r\n                <span className=\"sidebar-tooltip group-hover:scale-100\">Home</span>\r\n            </div>\r\n            <div className=\"sidebar-icon group\">\r\n                <Link to=\"./friends/friendRequestList\"><AiOutlineUserAdd size=\"48\"/></Link>\r\n                <span className=\"sidebar-tooltip group-hover:scale-100\">Friend requests</span>\r\n                <div className=\"red-dot\" hidden id=\"red_circle\"></div>\r\n            </div>\r\n            <div className=\"sidebar-icon group\">\r\n                <AiOutlineLogout size=\"48\" onClick={exit}/>\r\n                <span className=\"sidebar-tooltip group-hover:scale-100\">Logout</span>\r\n            </div>\r\n        </div>\r\n  )\r\n}\r\n\r\nexport default Sidebar;","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendRequestListContainer.js",["134","135","136","137"],[],"import React, {useState, useEffect, useContext, Navigate} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\n// import FriendContext from '../context/FriendContext'\r\nimport configData from '../config.json'\r\n\r\nconst FriendRequestListContainer = () => {\r\n\r\n  let [friendRequest, setfriendRequest] = useState([])\r\n  let { WebSocket, authToken} = useContext(AuthContext) \r\n  \r\n    // WebSocket.onmessage = function (e) {\r\n    //     let data = JSON.parse(e.data)\r\n    //     if(data.type == \"friendRequest\")\r\n    //     {\r\n    //         setTimeout(() => {\r\n    //             getFriendRequest()\r\n    //           }, 100);\r\n    //     }\r\n    //     // console.log(WSdata)\r\n    // }\r\n\r\n  let getFriendRequest = async () => {\r\n    let response = await fetch(configData.BACKEND_URL+'users/friendrequest/getFriendRequest', {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      },\r\n    })\r\n    let data = await response.json()\r\n    console.log(data)\r\n    setfriendRequest(data)\r\n  }\r\n\r\n  let acceptFriendRequest = async (username) => {\r\n    let response = await fetch(configData.BACKEND_URL+'users/friendrequest/acceptFriendRequest/' + username, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      },\r\n    })\r\n    window.location.reload()\r\n    WebSocket.send(JSON.stringify({\r\n      'friendName': username,\r\n      'type': 'friend_request',\r\n  }))\r\n  }\r\n\r\n  let declineFriendRequest = async (username) => {\r\n    let response = await fetch(configData.BACKEND_URL+'users/friendrequest/declineFriendRequest/' + username, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      },\r\n    })\r\n    getFriendRequest()\r\n  }\r\n\r\n  useEffect(() => {\r\n    getFriendRequest()\r\n  }, [])\r\n\r\n  return (\r\n    <div className='friendrequest_container flex-col flex-grow'>\r\n        <h1 className='text-3xl font-semibold text-[#d9e0eb] border-b-2 border-gray-900 p-4'>Your friend requests are here!</h1>\r\n        <div className='overflow-y-scroll flex-grow scrollbar'>\r\n          {friendRequest.map(r => (\r\n            <div className='friend_request_elem w-full'>\r\n                <p1 className='font-semibold'>{r.sender[\"username\"]}</p1>\r\n                <div className='ml-auto flex left-0'>\r\n                  <button className='friend-request-elem-buttons bg-green-600 hover:bg-green-500 transition-all duration-150' onClick={() => acceptFriendRequest(r.sender[\"username\"])}>Accept</button>\r\n                  <button className='friend-request-elem-buttons bg-red-600 hover:bg-red-500 transition-all duration-150'onClick={() => declineFriendRequest(r.sender[\"username\"])}>Decline</button>\r\n                </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default FriendRequestListContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\AddFriendContainer.js",["138"],[],"import React, {useState, useEffect, useContext} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\nimport FriendContext from '../context/FriendContext'\r\nimport configData from '../config.json'\r\n\r\nconst AddFriendContainer = () => {\r\n\r\n    let [users, setUsers] = useState([])\r\n    let { WebSocket, authToken} = useContext(AuthContext)\r\n    let {friends} = useContext(FriendContext)\r\n    // friend_search\r\n    let getUesrs = async (e) => {\r\n        e.preventDefault();\r\n        // alert(document.getElementById('friend_search').value);\r\n        let username = document.getElementById('friend_search').value\r\n        let response = await fetch(configData.BACKEND_URL+'users/friendrequest/getUsers/'+ username, {\r\n            method: 'GET',\r\n            headers:{\r\n                'Content-Type':'application/json',\r\n                'Authorization':'Bearer ' + String(authToken.access)\r\n            },\r\n        })\r\n        let data = await response.json()\r\n        setUsers(data)\r\n        console.log(Object.keys(data))\r\n        if (Object.keys(data).length === 0){\r\n            // console.log(\"worky\")\r\n            document.getElementById(\"friend_text\").innerHTML = \"Account Not Found\"\r\n        } \r\n        else{\r\n            document.getElementById(\"friend_text\").innerHTML = \"\"\r\n        }\r\n    }\r\n\r\n    let sendFriendRequest = async (username) => {\r\n        // ToDo Send Friend request using http post and websocket\r\n        alert(username)\r\n\r\n        //  friendrequest/sendFriendRequest/<str:friendName>\r\n        let response = await fetch(configData.BACKEND_URL+'users/friendrequest/sendFriendRequest/'+ username, {\r\n            method: 'GET',\r\n            headers:{\r\n                'Content-Type':'application/json',\r\n                'Authorization':'Bearer ' + String(authToken.access)\r\n            },\r\n        })\r\n        let data = await response.json()\r\n        console.log(data.status)\r\n        if (data.status === \"already exist\"){\r\n            alert(\"Friend request was already sended\")\r\n        }\r\n        else\r\n        {\r\n            // Sending message to websocket (so that receivee can see friend request apear in real time)\r\n            WebSocket.send(JSON.stringify({\r\n                'friendName': username,\r\n                'type': 'friend_request',\r\n            }))\r\n        }\r\n    }\r\n\r\n\r\n  return (\r\n    <div className='friendadd_container flex flex-col flex-grow'>\r\n        <div className='friend_header_container'>\r\n            <h1 className='text-3xl font-semibold'>You can add friends by searching their username</h1> <br/>\r\n            <form onSubmit={getUesrs} className=\"friend_search flex flex-grow justify-center\" autoComplete=\"off\"> \r\n                <input type=\"text\" id=\"friend_search\" placeholder=\"Type username and hit enter\"/>\r\n                {/* <button type=\"submit\">Search</button> */}\r\n            </form>\r\n        </div>\r\n            \r\n        <ul className=\"friendadd_list scrollbar\">\r\n            <div id=\"friend_text\" className=\"text-[#d9e0eb] flex justify-center p-2 text-xl\"></div>\r\n            {users.map(user => (\r\n                <div className=\"friend_container\">\r\n                    <text className='friend_container_username'>{user.username}</text>\r\n                    {friends.includes(user.username) ? (\r\n                        <text className=\"friend_container_UFWTP text-gray-950 font-bold text-lg\">You're friends with this person</text>\r\n                    ): (\r\n                        <button className='add-friend-button ml-auto h-10 w-48'onClick={() => sendFriendRequest(user.username)}>Send Friend Request</button>\r\n                    )}\r\n                    \r\n                </div>\r\n            ))}\r\n        </ul>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default AddFriendContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MessageContainer.js",["139","140","141","142","143","144","145","146"],[],"import React, {useState, useEffect, useContext, useRef}  from 'react'\r\nimport {  useParams } from \"react-router-dom\";\r\nimport AuthContext from '../context/AuthContext'\r\nimport ConControls from './ConControls';\r\nimport ConTest from './ConTest'\r\nimport configData from '../config.json'\r\nimport { MdOutlineFileUpload } from \"react-icons/md\";\r\n\r\nconst MessageContainer = () => {\r\n  let [messageRTC, setMessageRTC] = useState(null)\r\n  \r\n  // Getting username from URL\r\n  let { username } = useParams();\r\n  let string = username.toString()\r\n\r\n\r\n  const containerRef = useRef(null)\r\n\r\n  // Creating messages var \r\n  // Getting messages from session storage for current friend\r\n  // If session storage doesnt have any values it means:\r\n  // 1: Theres is no messages in current chatroom\r\n  // 2: or it is first load of chatroom\r\n  // in any cases above, chatroom will send to django getMessages request\r\n  let [messages, setMessages] = useState([]) \r\n  \r\n  let newestMessage = useRef({})\r\n  let oldestMessage = useRef({})\r\n\r\n  // CurrentMessages contains messages from every friend that were loaded in current session\r\n  let currentMessages = useRef({})\r\n\r\n  let { WebSocket, authToken, user} = useContext(AuthContext)\r\n  \r\n  // Initializint empty list\r\n  let updates = []\r\n  // Checking if key 'update' exist in session storage\r\n  // If not:\r\n  if (sessionStorage.getItem(\"Updates\") == null)\r\n  {\r\n    // Creating Key with empty list as value\r\n    sessionStorage.setItem(\"Updates\", JSON.stringify(updates))\r\n  } \r\n  // Updating list with current values from session storage\r\n  // so that list is up to date\r\n  updates = sessionStorage.getItem(\"Updates\")\r\n\r\n  // functions 'useEffect()' trigges on the first load\r\n  // and every time 'username' is updated \r\n  useEffect(() => {\r\n    \r\n\r\n    if (!currentMessages.current[`${string}`])\r\n    {\r\n      currentMessages.current[`${string}`] = [];\r\n    }\r\n\r\n    // Checking if messages are empty\r\n    if (currentMessages.current[`${string}`].length == 0)\r\n    {\r\n      // If so, sending to django reqeust for new messages from database\r\n      getMessages(40, \"321\" ,1)\r\n    }\r\n    else if(updates.includes(username))\r\n    {\r\n      // If not and update list contains friend username\r\n      // It means friend send to this user message\r\n      // and message var needs to be updated \r\n\r\n      // Removing friend from update list\r\n      removeFromStorage(username)\r\n      // Getting new messages \r\n      // (In Future there should be update function that will only get new messages, instead getting all messages from current chatroom) DONE\r\n      getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n    }\r\n    else\r\n    {\r\n      // else it means there was no updates/messages sent\r\n      // so setting messages from currentMessages ref, stored before\r\n      setMessages(currentMessages.current[`${string}`])\r\n    }\r\n\r\n    // \r\n    const handleScroll = () => {\r\n      if (containerRef.current.scrollTop === 0) {\r\n        getMessages(40, oldestMessage.current[`${string}`].created, 3, 2)\r\n      }\r\n    };\r\n\r\n    containerRef.current.addEventListener('scroll', handleScroll);\r\n\r\n    return () => {\r\n      if (containerRef.current){\r\n        containerRef.current.removeEventListener('scroll', handleScroll);\r\n      }\r\n    };\r\n\r\n  }, [username])\r\n  \r\n  WebSocket.onclose = () => {\r\n    console.log(\"Websocket Client Disconnected\");\r\n    // window.location.reload()\r\n  }\r\n\r\n  WebSocket.onopen = () => {\r\n    console.log('WebSocket Client Connected');\r\n    WebSocket.send(JSON.stringify({\r\n      'message': 'friend is connected',\r\n      'friendName': string,\r\n      'type': 'message_update',\r\n    }))\r\n  }\r\n  // Listener for upcoming messages from django\r\n  // I dont think async is required, but who knows \r\n  WebSocket.onmessage = function (e) {\r\n    let data = JSON.parse(e.data)\r\n    // Console logging messages for debugging\r\n    // console.log('Data:', data)\r\n    // console.log(JSON.parse(e.data))\r\n    if(data.type === 'friendRequest' && data.friend != user.username)\r\n    {\r\n      window.location.reload()\r\n    }\r\n    // If user recives chat_update prompt and is from a friend \r\n    // whos chatroom is open: update messages \r\n    if(data.type === 'chat_update' && data.friend === string){\r\n      // console.log('chat')\r\n      // 100ms delay is required, for some bizarre reasons\r\n      // if there is no delay, getMessages() works every 3rd time\r\n      setTimeout(() => {\r\n        if (newestMessage.current[`${string}`])\r\n        {\r\n          getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n        }\r\n        else\r\n        {\r\n          getMessages(10, \"321\" ,1)\r\n        }\r\n      }, 300);\r\n      // setMessageRTC(data)\r\n      // isCalling(true)\r\n    }\r\n    else if (!updates.includes(data.friend) && data.friend !== user.username)\r\n    {\r\n        // If friend sent you messages \r\n        // and that friends chatroom wasnt open\r\n        // saving that friend username to update list \r\n        pushToStorage(data.friend);          \r\n    }\r\n    else //if(data.type === \"init_call\" && data.friend === string)\r\n    {\r\n      // console.log(\"Your friends is calling\")\r\n      setMessageRTC(data)\r\n      // isCalling(true)\r\n      // isFcall(true)\r\n    }\r\n  }\r\n  // Getting messages form django backend\r\n  let getMessages = async (count = 1, date = \"1987-07-18T20:59:26.076557Z\", mode = 1, mode2 = 1) => {\r\n    let respone = await fetch(configData.BACKEND_URL+`users/rooms/${string}/${count}/${date}/${mode}`, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      }\r\n    }, [])\r\n    \r\n    let data = await respone.json()\r\n    // console.log(data)\r\n    \r\n    // console.log(currentMessages.current)\r\n    // console.log(currentMessages.current[`${string}`])\r\n    \r\n    // Adding messages to currentMessage ref\r\n    addToMessages(data, mode2)\r\n    \r\n    // \r\n    setMessages(currentMessages.current[`${string}`])\r\n    // console.log(\"newest: \" + newestMessage.current[`${string}`].created)\r\n    // console.log(\"oldest: \" + oldestMessage.current[`${string}`].created)\r\n  }\r\n  \r\n  // Function that adds messages to storage and \r\n  // Keep track of newest and oldest messages\r\n  let addToMessages = (data, mode = 1) => {\r\n    \r\n    // Adding new message/s to ref \r\n    // mode 1 adding ms at the beginning of the list\r\n    // mode 2 adding ms at the end of the list\r\n    if (mode == 1)\r\n    {\r\n      currentMessages.current[`${string}`] = [...currentMessages.current[string], ...data];\r\n    }\r\n    else if (mode == 2)\r\n    {\r\n      currentMessages.current[`${string}`] = [...data, ...currentMessages.current[string]];\r\n    }\r\n    \r\n    newestMessage.current[`${string}`] = currentMessages.current[`${string}`][currentMessages.current[`${string}`].length - 1];\r\n    oldestMessage.current[`${string}`] = currentMessages.current[`${string}`][0];\r\n  }\r\n\r\n  \r\n  // Sending messages to djnago\r\n  let sendMessage = async (e) => {\r\n    e.preventDefault()\r\n    // Sending message to websocket\r\n    // And passing friend name from url\r\n    await fetch(configData.BACKEND_URL+'users/rooms/send/'+string, {\r\n      method: 'POST',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      }, \r\n      body:JSON.stringify(e.target.message.value)\r\n    })\r\n    WebSocket.send(JSON.stringify({\r\n      'message': 'message was sent',\r\n      'friendName': string,\r\n      'type': 'message_update',\r\n    }))\r\n    document.getElementById('mess').value = ''\r\n    \r\n    // Checking if message exist in chatroom\r\n    if (newestMessage.current[`${string}`])\r\n    {\r\n      getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n    }\r\n    else\r\n    {\r\n      getMessages(10, \"321\" ,1)\r\n    }\r\n\r\n  }\r\n\r\n  let getCSRFToken = async () => {\r\n    let response = await fetch(configData.BACKEND_URL+`users/get-csrf-token`, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      }\r\n    }, [])\r\n    let data = await response.json()\r\n    // console.log(data)\r\n    return data.csrfToken;\r\n  }\r\n\r\n  let uploadFile = async (e) => {\r\n    // Getting token as far as I know is not currently requierd\r\n    const csrfToken = await getCSRFToken()\r\n    // Getting file from html input\r\n    const file = e.target.files[0];\r\n\r\n    // Creating form object\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    formData.append('csrfmiddlewaretoken', csrfToken);\r\n\r\n    try{\r\n      let response = await fetch(configData.BACKEND_URL+'users/rooms/sendfile/'+string, {\r\n        method: 'POST',\r\n        headers:{\r\n          // 'Content-Type':'multipart/form-data',\r\n          'Authorization':'Bearer ' + String(authToken.access),\r\n          'X-CSRFToken': csrfToken\r\n          // 'Access-Control-Allow-Origin': 'origin-or-null / wildcard'\r\n        }, \r\n        body: formData\r\n      })\r\n  \r\n      document.getElementById('file_input').value = null\r\n  \r\n      if (!response.ok) {\r\n        // Parse the JSON error message\r\n        let errorData = await response.json();\r\n        let errorMessage = errorData.error || \"An error occurred\";\r\n        throw new Error(errorMessage);\r\n      }\r\n  \r\n      WebSocket.send(JSON.stringify({\r\n        'message': 'message was sent',\r\n        'friendName': string,\r\n        'type': 'message_update',\r\n      }))\r\n  \r\n      getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n    } catch (error){\r\n      console.error(\"Upload failed:\", error.message);\r\n      alert(\"Upload failed: \" + error.message);\r\n    }\r\n  }\r\n\r\n  let downloadFile = (id) => {\r\n    window.open(configData.BACKEND_URL+`users/rooms/download/${id}/${authToken.access}`, '_blank').focus()\r\n  }\r\n\r\n  function pushToStorage(value)\r\n  {\r\n    // Getting values from storage\r\n    let array = JSON.parse(sessionStorage.getItem(\"Updates\"))\r\n    // Adding value to array\r\n    array.push(value)\r\n    updates = array\r\n    // Overwrites current session storage with new one\r\n    sessionStorage.setItem(\"Updates\", JSON.stringify(array))\r\n  }\r\n\r\n  function removeFromStorage(value)\r\n  {\r\n    // getting data from session storage \r\n    let array = JSON.parse(sessionStorage.getItem(\"Updates\"))\r\n    // Getting index value of passed value (param)\r\n    let index = array.indexOf(value)\r\n    // If value exist in list\r\n    if (index > -1)\r\n    {\r\n      // Removing that value from list\r\n      array.splice(index, 1)\r\n    }\r\n    // Updating 'update' list and saving it to session storage too \r\n    updates = array\r\n    sessionStorage.setItem(\"Updates\", JSON.stringify(array))\r\n  }\r\n\r\n  let FileLinkComponent = (message) => {\r\n    return (\r\n      <div className='chat-elem'>\r\n        <div className='inline-flex'>\r\n          {message.message.user.username}: <div className='file_elem' onClick={() => downloadFile(message.message.file.id) }>{message.message.file.fileName} {formatFileSize(message.message.file.fileSize)}</div>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  const formatFileSize = (size) => {\r\n    if (size < 1024) {\r\n        return size + ' B';\r\n    } else if (size < 1024 * 1024) {\r\n        return (size / 1024).toFixed(2) + ' KB';\r\n    } else {\r\n        return (size / (1024 * 1024)).toFixed(2) + ' MB';\r\n    }\r\n};\r\n\r\n  function MessageForRender()\r\n  {\r\n    if (messages.length == 0)\r\n    {\r\n      return <div className='chat-no-msg'>No Messages with @{username}</div>\r\n    }\r\n    else\r\n    {\r\n      return( \r\n        messages.map(f => f.isIncludeFile === false ? (<div className='chat-elem' key={f.id}>{f.user.username}: {f.body}</div>) : (<FileLinkComponent message={f}/>))\r\n      )\r\n    }\r\n  }\r\n  return (\r\n    <div className='message_container flex flex-col flex-grow'>\r\n      <div className='message_container_ui'>\r\n        {/* <ConControls data={messageRTC} /> */}\r\n        <ConTest data={messageRTC}/>\r\n      </div>\r\n      <div className='message_container_chat '>\r\n        <ul className='message_list scrollbar' ref={containerRef}>\r\n          <MessageForRender />\r\n        </ul>\r\n        <div className='message_text_input'>\r\n          <form onSubmit={sendMessage} autoComplete=\"off\">\r\n            <input type=\"text\" id='mess' name=\"message\" autoFocus placeholder='type here'/>\r\n            <label id='message_text_input-file' >\r\n              <input type=\"file\" id=\"file_input\" name=\"file\" onChange={uploadFile}/>\r\n              <MdOutlineFileUpload />               \r\n            </label>\r\n          </form>\r\n        </div>\r\n      </div>\r\n      \r\n    </div>\r\n  )\r\n}\r\n\r\nexport default MessageContainer\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ConControls.js",["147","148","149","150","151","152","153","154","155","156","157","158"],[],"import {React, useEffect, useContext, useState} from 'react'\r\nimport {  useParams } from \"react-router-dom\";\r\nimport CallIcon from \"../assets/phone-call.png\"\r\nimport CameraIcon from \"../assets/camera.png\"\r\nimport MicIcon from \"../assets/mic.png\"\r\nimport PhoneIcon from \"../assets/phone.png\"\r\nimport EndCall from \"../assets/end-call.png\"\r\nimport AuthContext from '../context/AuthContext'\r\n\r\nlet localStream;\r\nlet remoteStream;\r\nlet peerConnection\r\nlet isVisible = false\r\nlet is_in_call = false;\r\nlet friend_call = \"none\"\r\nlet isCalling = false\r\n\r\nconst ConControls = ({data = null, fcall}) => {\r\n    // Getting username from URL\r\n    let { username } = useParams();\r\n    let string = username.toString();\r\n\r\n    // const [isVisible, setIsVisible] = useState(false);\r\n\r\n    // Getting access to authToken and WebSocket info from AuthContext\r\n    let { WebSocket, authToken, user} = useContext(AuthContext)\r\n\r\n    // !!! prop for sending ice can using webSockets !!!\r\n    \r\n    // WebSocket.send(JSON.stringify({\r\n    //     'message': 'message was sent',\r\n    //     'friendName': string,\r\n    //     'type': 'init_call',\r\n    // }))\r\n\r\n\r\n\r\n    const servers = \r\n    {\r\n        iceServers:[\r\n            {\r\n                urls:['stun:stun.l.google.com:19302', 'stun:stun2.l.google.com:19302']\r\n            }\r\n        ]\r\n    } \r\n    \r\n\r\n    let setup_ui = async () => {\r\n        console.log(\"test1\")\r\n        // Getting UI element    \r\n        // let callBTN = document.getElementById(\"call-controls\");\r\n        let button = document.getElementById(\"ConControls-Call-icon\");\r\n        button.style.visibility = \"hidden\";\r\n        // Getting chat element\r\n        let chat = document.getElementsByClassName(\"message_container_chat\")[0];\r\n        let message_list = document.getElementsByClassName(\"message_list\")[0];\r\n        \r\n        // Getting video elemnt\r\n        let user1 = document.getElementById('user-1');\r\n        let user2 = document.getElementById('user-2');\r\n\r\n        // Getting permisson from the user\r\n        localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true}); // getting problem here\r\n\r\n        console.log('test2')\r\n\r\n        let video_container = document.getElementById(\"video_container\");\r\n        video_container.style.display = \"grid\"\r\n\r\n        // Setting up video container style\r\n        // callBTN.style.display = 'visible';\r\n        user1.style.visibility = 'visible';\r\n        user1.style.height = \"100%\";\r\n        user2.style.visibility = 'visible';\r\n        user2.style.height = \"100%\";\r\n        isVisible = true\r\n        // Setting up src stream for user 1\r\n        user1.srcObject = localStream;\r\n        \r\n        user1.onloadedmetadata = function(e) {\r\n            user1.play();\r\n        };\r\n\r\n        // uiNav.style.height = \"50vh\";\r\n        // chat.style.height = \"45vh\";\r\n        message_list.style.height = \"50vh\";\r\n\r\n        is_in_call = true;\r\n    }\r\n\r\n    // Changing layout of website\r\n    let init_call = async () =>\r\n    {\r\n        friend_call = string\r\n        setup_ui()\r\n\r\n        create_offer()\r\n        \r\n        // alert(\"ended\");\r\n    }\r\n\r\n    let createPeerConnection = async () => {\r\n        // Creating connection object\r\n        peerConnection = new RTCPeerConnection(servers)\r\n\r\n        // Creating friend's stream object\r\n        remoteStream = new MediaStream()\r\n        // Setting html video object to friend's stream\r\n        document.getElementById('user-2').srcObject = remoteStream;\r\n\r\n        if(!localStream){\r\n            localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true})\r\n            document.getElementById('user-1').srcObject = localStream\r\n        }\r\n\r\n        // For every track, tracks are added to localStream (user's stream)\r\n        localStream.getTracks().forEach((track) => {\r\n            peerConnection.addTrack(track, localStream)\r\n        })\r\n\r\n        // For every track from friend's peer connection, tracks are added to remoteStream (Friend's stream)\r\n        peerConnection.ontrack = (e) => {\r\n            e.streams[0].getTracks().forEach((track) => {\r\n                remoteStream.addTrack(track)\r\n            })\r\n        }\r\n\r\n        // Debuging\r\n        peerConnection.onicecandidate = async (e) => {\r\n            if(e.candidate){\r\n                // console.log('New ICE candidate: ', e.candidate)\r\n                WebSocket.send(JSON.stringify({\r\n                    'message': e.candidate,\r\n                    'friendName': string,\r\n                    'type': 'candidate',\r\n                }))\r\n            }\r\n        }\r\n    }\r\n\r\n    let create_offer = async () => \r\n    {\r\n        await createPeerConnection()\r\n\r\n        let offer = await peerConnection.createOffer()\r\n        // sets local descirpiton and also fires of peerConnection.onicecandidate listener\r\n        await peerConnection.setLocalDescription(offer)\r\n\r\n        const delay = ms => new Promise(\r\n            resolve => setTimeout(resolve, ms)\r\n        );\r\n        await delay(400)\r\n\r\n        WebSocket.send(JSON.stringify({\r\n            'message': offer,\r\n            'friendName': string,\r\n            'type': 'init_call',\r\n        }))\r\n        // console.log('Offer: ', offer)\r\n        // console.log(peerConnection)\r\n    }\r\n\r\n    let create_answer = async (offer) => {\r\n        await createPeerConnection()\r\n\r\n        await peerConnection.setRemoteDescription(offer)\r\n\r\n        let answer = await peerConnection.createAnswer()\r\n        await peerConnection.setLocalDescription(answer)\r\n\r\n        // console.log(string)\r\n        console.log(\"asnwer: |\")\r\n        console.log(answer)\r\n        // creating delay to ensure that aswer is created before sending message\r\n        // if not first init of the call wont work :( (I have absolutely no idea how to fix this)\r\n        const delay = ms => new Promise(\r\n            resolve => setTimeout(resolve, ms)\r\n        );\r\n        await delay(1000)\r\n        WebSocket.send(JSON.stringify({\r\n            'message': answer,\r\n            'friendName': string,\r\n            'type': 'answer',\r\n        }))\r\n\r\n    }\r\n\r\n    let addAnswer = async (answer) => {\r\n        // console.log(\"tests: \")\r\n        // console.log(peerConnection)\r\n        if (!peerConnection.currentRemoteDescription) {\r\n            // console.log(peerConnection) \r\n            console.log(peerConnection.currentRemoteDescription)\r\n            // count++\r\n            await peerConnection.setRemoteDescription(answer);\r\n        }\r\n      };\r\n\r\n    let handleCallFromPeer = async (data) => {\r\n        // quick delay hack (not working in this case :( i hate life )\r\n        // const delay = ms => new Promise(\r\n        //     resolve => setTimeout(resolve, ms)\r\n        // );\r\n        // await delay(300)\r\n        if (data)\r\n        {\r\n            // Debuggin stuff\r\n            // if (data.friend == string)\r\n            // {\r\n                // console.log(data)\r\n            // }\r\n            // If data is type init_call and was send from a friend\r\n            if (data.type == \"init_call\" && data.friend == string)\r\n            {\r\n                // Setting flag that will fire off ui calling prompt\r\n                isCalling = true\r\n                // Getting accept_call button and adding event listener onclick \r\n                // that will fire of createReqeust function with passed 'data' param\r\n                let button = document.getElementById(\"call_request_accept_call\")\r\n                button.addEventListener(\"click\", createRequest)\r\n                button.myParam = data\r\n            }\r\n            \r\n            if (data.message.type === \"answer\" && data.friend == string)\r\n            {\r\n                // Adding answer\r\n                addAnswer(data.message)\r\n                // console.log(\"add_answer\")\r\n                // console.log(data.message)\r\n            }\r\n            \r\n            if (data.type == \"candidate\" && data.friend == string)\r\n            {\r\n                // creating delay hack to ensure that create_answer() sends answer object first via websocket\r\n                // possible fix:\r\n                // create system where peer has to accept call and this will ensure time buffer betweem adding Ice Candidates and receiving answer object\r\n                // answer object must be received before adding any Ice Candidates if not Ice Candidates on peer side will be added to null local description (that will throw error)\r\n                const delay = ms => new Promise(\r\n                    resolve => setTimeout(resolve, ms)\r\n                );\r\n                await delay(1000)\r\n                console.log(\"ice tests\")\r\n                if(peerConnection){\r\n                    console.log(peerConnection.remoteDescription)\r\n                    peerConnection.addIceCandidate(data.message)\r\n\r\n                    console.log(\"addIceCandidate\")\r\n                }\r\n            }\r\n\r\n            if (data.type == \"end_call\" && is_in_call && friend_call == data.friend)\r\n            {\r\n                handleUserLeft()\r\n            }\r\n        }\r\n\r\n        // isCalling(false)\r\n    }\r\n    \r\n    // Creating positive answer to call \r\n    let createRequest = async (data) => {\r\n\r\n        // Saving friend name that user is in call with to var\r\n        friend_call = data.currentTarget.myParam.friend\r\n        // Changing ui \r\n        setup_ui()\r\n        // Creating answer ice object and sending it to a peer \r\n        create_answer(data.currentTarget.myParam.message)\r\n        \r\n        // Making ui call request disappear\r\n        isCalling = false\r\n    }\r\n\r\n    // TO FIX: object stream bug, in new call\r\n    let handleUserLeft = async () => {\r\n        \r\n        // Getting html element\r\n        let uiNav = document.getElementsByClassName(\"ConControls\")[0];\r\n        // Getting whole div that contains input message and list message\r\n        let chat = document.getElementsByClassName(\"message_container_chat\")[0];\r\n        // Getting list that contains messages\r\n        let message_list = document.getElementsByClassName(\"message_list\")[0];\r\n\r\n        // Changing back height setting\r\n        uiNav.style.height = \"auto\";\r\n        chat.style.height = \"auto\";\r\n        // Setting message list to 85% of website height\r\n        message_list.style.height = \"85vh\";\r\n        \r\n        // Getting html call button (green button that init the call)\r\n        let button = document.getElementById(\"ConControls-Call-icon\");\r\n        // Making button visible again\r\n        button.style.visibility = \"visible\";\r\n        \r\n        // Making div that contains video objects invisible\r\n        let video_container = document.getElementById(\"video_container\");\r\n        video_container.style.display = \"none\"\r\n        \r\n        // Getting users video objects\r\n        let user1 = document.getElementById('user-1');\r\n        let user2 = document.getElementById('user-2');\r\n        \r\n        // Making them also invinsible \r\n        user1.style.visibility = 'hidden';\r\n        user1.style.height = \"0%\";\r\n        user2.style.visibility = 'hidden';\r\n        user2.style.height = \"0%\";\r\n        \r\n        // Setting flags to false\r\n        isVisible = false\r\n        is_in_call = false\r\n        isCalling = false\r\n        \r\n        // Testing/debuggin/fixing bugs\r\n\r\n        // localStream.getTracks().forEach((track) => {\r\n            //     track.stop();\r\n            // })\r\n\r\n        // For every track, tracks are added to localStream (user's stream)\r\n        \r\n    \r\n        // console.log(peerConnection.getSenders())\r\n        // peerConnection.removeTrack(peerConnection.getSenders()[0])\r\n\r\n        // let videoTrack = localStream.getTracks().find(track => track.kind === 'video')\r\n        // localStream.getTracks().forEach((track) => {\r\n        //     console.log(track)\r\n        //     // track.stop();\r\n        //     localStream.removeTrack(track)\r\n        // })\r\n\r\n        // closing peer connection (sets connection to 'close' status, it doesn't destroying connection)\r\n        peerConnection.close()\r\n        // Temporary fix to object stream bug\r\n        window.location.reload()\r\n        // removeTrack()\r\n        \r\n        // Sending to peer 'end_call' prompt\r\n        WebSocket.send(JSON.stringify({\r\n            'message': 'end call',\r\n            'friendName': string,\r\n            'type': 'end_call',\r\n        }))\r\n    }\r\n\r\n    // Denying incoming call\r\n    let deny_call = () => {\r\n        isCalling = false\r\n\r\n        // Sending to peer 'end_call' prompt \r\n        WebSocket.send(JSON.stringify({\r\n            'message': 'end call',\r\n            'friendName': string,\r\n            'type': 'end_call',\r\n        }))\r\n    }\r\n\r\n    // Toggle user's stream camera\r\n    let toggle_camera = async () => {\r\n        // Getting user's stream object\r\n        let videoTrack = localStream.getTracks().find(track => track.kind === 'video')\r\n\r\n        if (videoTrack.enabled)\r\n        {\r\n            // Disabling video src\r\n            videoTrack.enabled = false\r\n            // Setting background color of button to red\r\n            document.getElementById('camera_btn').style.backgroundColor = 'rgb(255, 80, 80)'\r\n        }\r\n        else\r\n        {\r\n            // Enabling video src\r\n            videoTrack.enabled = true\r\n            // Setting background color of button to blue\r\n            document.getElementById('camera_btn').style.backgroundColor = 'rgb(102, 153, 255, .8)'\r\n        }\r\n    }\r\n\r\n    // Taggle user's stream audio\r\n    let toggle_audio = async () => {\r\n        // Getting user's stream object\r\n        let audioTrack = localStream.getTracks().find(track => track.kind === 'audio')\r\n\r\n        if (audioTrack.enabled)\r\n        {\r\n            // Disabling audio src\r\n            audioTrack.enabled = false\r\n            // Changing button background to red\r\n            document.getElementById('mic_btn').style.backgroundColor = 'rgb(255, 80, 80)'\r\n        }\r\n        else\r\n        {\r\n            // Enabling audio src\r\n            audioTrack.enabled = true\r\n            // Changing button background to blue\r\n            document.getElementById('mic_btn').style.backgroundColor = 'rgb(102, 153, 255, .8)'\r\n        }\r\n    }\r\n    \r\n    \r\n    useEffect(()=> {\r\n        // Adding event listenr that checks if user refreshed/close tab\r\n        window.addEventListener('beforeunload', handleUserLeft)\r\n        // if(is_in_call === true)\r\n        // {\r\n        //     init_call()\r\n        // }\r\n        // else\r\n        // {\r\n        //     // Getting UI element    \r\n        //     let uiNav = document.getElementsByClassName(\"ConControls\")[0];\r\n        //     // Getting chat element\r\n        //     let chat = document.getElementsByClassName(\"message_container_chat\")[0];\r\n        //     let message_list = document.getElementsByClassName(\"message_list\")[0];\r\n        //     uiNav.style.height = \"auto\";\r\n        //     chat.style.height = \"auto\";\r\n        //     message_list.style.height = \"85vh\";\r\n        // }\r\n        // // setup_ui()\r\n\r\n        // setIsVisible(false)\r\n    }, [])\r\n\r\n    // Logic for handling incoming call from ws\r\n    handleCallFromPeer(data)\r\n    \r\n    return (\r\n        <div className='main_uivideo_con'>\r\n            <div className='ConControls'>\r\n                <div id='ConControls-friendname'>{username}</div>\r\n                <div id='ConControls-Call-icon' onClick={init_call}><img src={CallIcon} alt=\"call\"/></div>\r\n            </div>\r\n            <div className='video_container' id='video_container' hidden>\r\n                <video className=\"video-player\" id='user-1' autoPlay playsInline ></video>\r\n                <video className=\"video-player\" id='user-2' autoPlay playsInline ></video>\r\n            </div>\r\n            <div className={isCalling ? 'visible' : 'hidden'} id='call_request'>\r\n                <div id='call_request_text'>\r\n                    {string} is calling you!\r\n                </div>\r\n                <div id='call_request_controls'>\r\n                    <div className='control-container' id='call_request_accept_call'>\r\n                        <img src={PhoneIcon} alt='accept_call' />\r\n                    </div>\r\n                    <div className='control-container' id='leave_btn' onClick={deny_call}>\r\n                        <img src={EndCall} alt='deny_call'/>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div className={isVisible ? 'visible' : 'hidden'} id='call_controls'>\r\n                <div className=\"control-container\" id=\"camera_btn\" onClick={toggle_camera}>\r\n                    <img src={CameraIcon} alt='camera_btn' />\r\n                </div>\r\n                <div className=\"control-container\" id=\"mic_btn\" onClick={toggle_audio}>\r\n                    <img src={MicIcon} alt='microphone_btn' />\r\n                </div>\r\n                <div className=\"control-container\" id=\"leave_btn\" onClick={handleUserLeft}>\r\n                    <img src={PhoneIcon} alt='leave_btn' />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ConControls","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ConTest.js",["159","160","161","162"],[],"import React, { useEffect, useContext, useState } from 'react';\r\nimport { useParams } from 'react-router-dom';\r\nimport CallIcon from '../assets/phone-call.png';\r\nimport CameraIcon from '../assets/camera.png';\r\nimport MicIcon from '../assets/mic.png';\r\nimport PhoneIcon from '../assets/phone.png';\r\nimport EndCall from '../assets/end-call.png';\r\nimport AuthContext from '../context/AuthContext';\r\n\r\nlet localStream;\r\nlet remoteStream;\r\nlet peerConnection;\r\nlet is_in_call = false;\r\nlet friend_call = 'none';\r\nlet isCalling = false;\r\n\r\nconst ConControls = ({ data }) => {\r\n  // Getting username from URL\r\n  let { username } = useParams();\r\n  let friendName = username.toString();\r\n\r\n  let { WebSocket, authToken, user } = useContext(AuthContext);\r\n\r\n  const servers = {\r\n    iceServers: [\r\n      {\r\n        urls: ['stun:stun.l.google.com:19302', 'stun:stun2.l.google.com:19302'],\r\n      },\r\n    ],\r\n  };\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('beforeunload', handleUserLeft);\r\n    return () => {\r\n      window.removeEventListener('beforeunload', handleUserLeft);\r\n    };\r\n  }, []);\r\n\r\n//   useEffect(() => {\r\n//     if (WebSocket) {\r\n//       WebSocket.onmessage = async (message) => {\r\n//         console.log('Received ws message');\r\n//         const data = JSON.parse(message.data);\r\n//         await handleCallFromPeer(data);\r\n//       };\r\n//     }\r\n//   }, [WebSocket]);\r\n\r\n  const setupUI = async () => {\r\n    const button = document.getElementById('ConControls-Call-icon');\r\n    button.style.visibility = 'hidden';\r\n\r\n    const message_list = document.getElementsByClassName('message_list')[0];\r\n    const user1 = document.getElementById('user-1');\r\n    const user2 = document.getElementById('user-2');\r\n\r\n    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n\r\n    const video_container = document.getElementById('video_container');\r\n    video_container.style.display = 'grid';\r\n\r\n    user1.style.visibility = 'visible';\r\n    user1.style.height = '100%';\r\n    user2.style.visibility = 'visible';\r\n    user2.style.height = '100%';\r\n\r\n    user1.srcObject = localStream;\r\n    user1.onloadedmetadata = function (e) {\r\n      user1.play();\r\n    //   user1.muted = true;\r\n    };\r\n\r\n    message_list.style.height = '50vh';\r\n\r\n    is_in_call = true;\r\n  };\r\n\r\n  const init_call = async () => {\r\n    friend_call = friendName;\r\n    await setupUI();\r\n    await createOffer();\r\n  };\r\n\r\n  const createPeerConnection = async () => {\r\n    peerConnection = new RTCPeerConnection(servers);\r\n\r\n    remoteStream = new MediaStream();\r\n    document.getElementById('user-2').srcObject = remoteStream;\r\n\r\n    if (!localStream) {\r\n      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n      document.getElementById('user-1').srcObject = localStream;\r\n    }\r\n\r\n    localStream.getTracks().forEach((track) => {\r\n      peerConnection.addTrack(track, localStream);\r\n    });\r\n\r\n    peerConnection.ontrack = (e) => {\r\n      e.streams[0].getTracks().forEach((track) => {\r\n        remoteStream.addTrack(track);\r\n      });\r\n    };\r\n\r\n    peerConnection.onicecandidate = async (e) => {\r\n      if (e.candidate) {\r\n        WebSocket.send(\r\n          JSON.stringify({\r\n            message: e.candidate,\r\n            friendName: friendName,\r\n            type: 'candidate',\r\n          })\r\n        );\r\n      }\r\n    };\r\n  };\r\n\r\n  const createOffer = async () => {\r\n    await createPeerConnection();\r\n\r\n    const offer = await peerConnection.createOffer();\r\n    await peerConnection.setLocalDescription(offer);\r\n\r\n    WebSocket.send(\r\n      JSON.stringify({\r\n        message: offer,\r\n        friendName: friendName,\r\n        type: 'init_call',\r\n      })\r\n    );\r\n  };\r\n\r\n  const createAnswer = async (offer) => {\r\n    await createPeerConnection();\r\n\r\n    await peerConnection.setRemoteDescription(offer);\r\n    const answer = await peerConnection.createAnswer();\r\n    await peerConnection.setLocalDescription(answer);\r\n\r\n    WebSocket.send(\r\n      JSON.stringify({\r\n        message: answer,\r\n        friendName: friendName,\r\n        type: 'answer',\r\n      })\r\n    );\r\n  };\r\n\r\n  const addAnswer = async (answer) => {\r\n    if (!peerConnection.currentRemoteDescription) {\r\n      await peerConnection.setRemoteDescription(answer);\r\n    }\r\n  };\r\n\r\n  const handleCallFromPeer = async (data) => {\r\n    if (data) {\r\n      if (data.type === 'init_call' && data.friend === friendName) {\r\n        isCalling = true;\r\n        const button = document.getElementById('call_request_accept_call');\r\n        button.onclick = () => createRequest(data);\r\n      } else if (data.message.type === 'answer' && data.friend === friendName) {\r\n        await addAnswer(data.message);\r\n      } else if (data.type === 'candidate' && data.friend === friendName) {\r\n        if (peerConnection) {\r\n          await peerConnection.addIceCandidate(new RTCIceCandidate(data.message));\r\n        }\r\n      } else if (data.type === 'end_call' && is_in_call && friend_call === data.friend) {\r\n        handleUserLeft();\r\n      }\r\n    }\r\n  };\r\n\r\n  const createRequest = async (data) => {\r\n    friend_call = data.friend;\r\n    await setupUI();\r\n    await createAnswer(data.message);\r\n    isCalling = false;\r\n  };\r\n\r\n  const handleUserLeft = async () => {\r\n    const uiNav = document.getElementsByClassName('ConControls')[0];\r\n    const chat = document.getElementsByClassName('message_container_chat')[0];\r\n    const message_list = document.getElementsByClassName('message_list')[0];\r\n\r\n    uiNav.style.height = 'auto';\r\n    chat.style.height = 'auto';\r\n    message_list.style.height = '85vh';\r\n\r\n    const button = document.getElementById('ConControls-Call-icon');\r\n    button.style.visibility = 'visible';\r\n\r\n    const video_container = document.getElementById('video_container');\r\n    video_container.style.display = 'none';\r\n\r\n    const user1 = document.getElementById('user-1');\r\n    const user2 = document.getElementById('user-2');\r\n\r\n    user1.style.visibility = 'hidden';\r\n    user1.style.height = '0%';\r\n    user2.style.visibility = 'hidden';\r\n    user2.style.height = '0%';\r\n\r\n    is_in_call = false;\r\n    isCalling = false;\r\n\r\n    if (peerConnection) {\r\n      peerConnection.ontrack = null;\r\n      peerConnection.onicecandidate = null;\r\n      peerConnection.close();\r\n      peerConnection = null;\r\n    }\r\n\r\n    if (localStream) {\r\n      localStream.getTracks().forEach((track) => track.stop());\r\n      localStream = null;\r\n    }\r\n\r\n    if (remoteStream) {\r\n      remoteStream.getTracks().forEach((track) => track.stop());\r\n      remoteStream = null;\r\n    }\r\n\r\n    WebSocket.send(\r\n      JSON.stringify({\r\n        message: 'end call',\r\n        friendName: friendName,\r\n        type: 'end_call',\r\n      })\r\n    );\r\n\r\n    window.location.reload();\r\n  };\r\n\r\n  const deny_call = () => {\r\n    isCalling = false;\r\n    WebSocket.send(\r\n      JSON.stringify({\r\n        message: 'end call',\r\n        friendName: friendName,\r\n        type: 'end_call',\r\n      })\r\n    );\r\n  };\r\n\r\n  const toggle_camera = () => {\r\n    const videoTrack = localStream.getTracks().find((track) => track.kind === 'video');\r\n    if (videoTrack.enabled) {\r\n      videoTrack.enabled = false;\r\n      document.getElementById('camera_btn').style.backgroundColor = 'rgb(255, 80, 80)';\r\n    } else {\r\n      videoTrack.enabled = true;\r\n      document.getElementById('camera_btn').style.backgroundColor = 'rgb(102, 153, 255, .8)';\r\n    }\r\n  };\r\n\r\n  const toggle_audio = () => {\r\n    const audioTrack = localStream.getTracks().find((track) => track.kind === 'audio');\r\n    if (audioTrack.enabled) {\r\n      audioTrack.enabled = false;\r\n      document.getElementById('mic_btn').style.backgroundColor = 'rgb(255, 80, 80)';\r\n    } else {\r\n      audioTrack.enabled = true;\r\n      document.getElementById('mic_btn').style.backgroundColor = 'rgb(102, 153, 255, .8)';\r\n    }\r\n  };\r\n\r\n  handleCallFromPeer(data);\r\n\r\n  return (\r\n    <div className='main_uivideo_con'>\r\n      <div className='ConControls'>\r\n        <div id='ConControls-friendname'>{username}</div>\r\n        <div id='ConControls-Call-icon' onClick={init_call}>\r\n          <img src={CallIcon} alt='call' />\r\n        </div>\r\n      </div>\r\n      <div className='video_container' id='video_container' hidden>\r\n        <video className='video-player' id='user-1' autoPlay playsInline muted></video>\r\n        <video className='video-player' id='user-2' autoPlay playsInline></video>\r\n      </div>\r\n      <div className={isCalling ? 'visible' : 'hidden'} id='call_request'>\r\n        <div id='call_request_text'>{username} is calling you!</div>\r\n        <div id='call_request_controls'>\r\n          <div className='control-container' id='call_request_accept_call'>\r\n            <img src={PhoneIcon} alt='accept_call' />\r\n          </div>\r\n          <div className='control-container' id='leave_btn' onClick={deny_call}>\r\n            <img src={EndCall} alt='deny_call' />\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div className={is_in_call ? 'visible' : 'hidden'} id='call_controls'>\r\n        <div className='control-container' id='camera_btn' onClick={toggle_camera}>\r\n          <img src={CameraIcon} alt='camera_btn' />\r\n        </div>\r\n        <div className='control-container' id='mic_btn' onClick={toggle_audio}>\r\n          <img src={MicIcon} alt='mic_btn' />\r\n        </div>\r\n        <div className='control-container' id='leave_btn' onClick={handleUserLeft}>\r\n          <img src={PhoneIcon} alt='leave_btn' />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ConControls;\r\n",{"ruleId":"163","severity":1,"message":"164","line":2,"column":8,"nodeType":"165","messageId":"166","endLine":2,"endColumn":14},{"ruleId":"163","severity":1,"message":"167","line":3,"column":8,"nodeType":"165","messageId":"166","endLine":3,"endColumn":19},{"ruleId":"163","severity":1,"message":"168","line":6,"column":14,"nodeType":"165","messageId":"166","endLine":6,"endColumn":24},{"ruleId":"169","severity":1,"message":"170","line":156,"column":8,"nodeType":"171","endLine":156,"endColumn":39,"suggestions":"172"},{"ruleId":"163","severity":1,"message":"173","line":1,"column":16,"nodeType":"165","messageId":"166","endLine":1,"endColumn":24},{"ruleId":"163","severity":1,"message":"174","line":1,"column":26,"nodeType":"165","messageId":"166","endLine":1,"endColumn":35},{"ruleId":"163","severity":1,"message":"175","line":1,"column":37,"nodeType":"165","messageId":"166","endLine":1,"endColumn":47},{"ruleId":"163","severity":1,"message":"167","line":2,"column":8,"nodeType":"165","messageId":"166","endLine":2,"endColumn":19},{"ruleId":"163","severity":1,"message":"176","line":3,"column":8,"nodeType":"165","messageId":"166","endLine":3,"endColumn":21},{"ruleId":"163","severity":1,"message":"177","line":18,"column":15,"nodeType":"165","messageId":"166","endLine":18,"endColumn":28},{"ruleId":"178","severity":1,"message":"179","line":52,"column":28,"nodeType":"180","messageId":"181","endLine":52,"endColumn":30},{"ruleId":"178","severity":1,"message":"182","line":73,"column":24,"nodeType":"180","messageId":"181","endLine":73,"endColumn":26},{"ruleId":"178","severity":1,"message":"182","line":82,"column":24,"nodeType":"180","messageId":"181","endLine":82,"endColumn":26},{"ruleId":"163","severity":1,"message":"183","line":4,"column":8,"nodeType":"165","messageId":"166","endLine":4,"endColumn":21},{"ruleId":"163","severity":1,"message":"173","line":1,"column":28,"nodeType":"165","messageId":"166","endLine":1,"endColumn":36},{"ruleId":"163","severity":1,"message":"174","line":1,"column":38,"nodeType":"165","messageId":"166","endLine":1,"endColumn":47},{"ruleId":"163","severity":1,"message":"167","line":7,"column":8,"nodeType":"165","messageId":"166","endLine":7,"endColumn":19},{"ruleId":"169","severity":1,"message":"184","line":49,"column":8,"nodeType":"171","endLine":49,"endColumn":10,"suggestions":"185"},{"ruleId":"163","severity":1,"message":"173","line":1,"column":16,"nodeType":"165","messageId":"166","endLine":1,"endColumn":24},{"ruleId":"163","severity":1,"message":"174","line":1,"column":26,"nodeType":"165","messageId":"166","endLine":1,"endColumn":35},{"ruleId":"163","severity":1,"message":"186","line":5,"column":7,"nodeType":"165","messageId":"166","endLine":5,"endColumn":24},{"ruleId":"169","severity":1,"message":"187","line":47,"column":10,"nodeType":"171","endLine":47,"endColumn":12,"suggestions":"188"},{"ruleId":"163","severity":1,"message":"189","line":1,"column":49,"nodeType":"165","messageId":"166","endLine":1,"endColumn":57},{"ruleId":"163","severity":1,"message":"190","line":36,"column":9,"nodeType":"165","messageId":"166","endLine":36,"endColumn":17},{"ruleId":"163","severity":1,"message":"190","line":51,"column":9,"nodeType":"165","messageId":"166","endLine":51,"endColumn":17},{"ruleId":"169","severity":1,"message":"187","line":63,"column":6,"nodeType":"171","endLine":63,"endColumn":8,"suggestions":"191"},{"ruleId":"163","severity":1,"message":"174","line":1,"column":26,"nodeType":"165","messageId":"166","endLine":1,"endColumn":35},{"ruleId":"163","severity":1,"message":"192","line":4,"column":8,"nodeType":"165","messageId":"166","endLine":4,"endColumn":19},{"ruleId":"178","severity":1,"message":"182","line":59,"column":53,"nodeType":"180","messageId":"181","endLine":59,"endColumn":55},{"ruleId":"169","severity":1,"message":"193","line":94,"column":22,"nodeType":"165","endLine":94,"endColumn":29},{"ruleId":"169","severity":1,"message":"194","line":98,"column":6,"nodeType":"171","endLine":98,"endColumn":16,"suggestions":"195"},{"ruleId":"178","severity":1,"message":"179","line":120,"column":53,"nodeType":"180","messageId":"181","endLine":120,"endColumn":55},{"ruleId":"178","severity":1,"message":"182","line":190,"column":14,"nodeType":"180","messageId":"181","endLine":190,"endColumn":16},{"ruleId":"178","severity":1,"message":"182","line":194,"column":19,"nodeType":"180","messageId":"181","endLine":194,"endColumn":21},{"ruleId":"178","severity":1,"message":"182","line":348,"column":25,"nodeType":"180","messageId":"181","endLine":348,"endColumn":27},{"ruleId":"163","severity":1,"message":"173","line":1,"column":39,"nodeType":"165","messageId":"166","endLine":1,"endColumn":47},{"ruleId":"163","severity":1,"message":"196","line":26,"column":22,"nodeType":"165","messageId":"166","endLine":26,"endColumn":31},{"ruleId":"163","severity":1,"message":"197","line":26,"column":33,"nodeType":"165","messageId":"166","endLine":26,"endColumn":37},{"ruleId":"163","severity":1,"message":"198","line":55,"column":13,"nodeType":"165","messageId":"166","endLine":55,"endColumn":17},{"ruleId":"178","severity":1,"message":"182","line":213,"column":27,"nodeType":"180","messageId":"181","endLine":213,"endColumn":29},{"ruleId":"178","severity":1,"message":"182","line":213,"column":57,"nodeType":"180","messageId":"181","endLine":213,"endColumn":59},{"ruleId":"178","severity":1,"message":"182","line":224,"column":63,"nodeType":"180","messageId":"181","endLine":224,"endColumn":65},{"ruleId":"178","severity":1,"message":"182","line":232,"column":27,"nodeType":"180","messageId":"181","endLine":232,"endColumn":29},{"ruleId":"178","severity":1,"message":"182","line":232,"column":57,"nodeType":"180","messageId":"181","endLine":232,"endColumn":59},{"ruleId":"178","severity":1,"message":"182","line":251,"column":27,"nodeType":"180","messageId":"181","endLine":251,"endColumn":29},{"ruleId":"178","severity":1,"message":"182","line":251,"column":70,"nodeType":"180","messageId":"181","endLine":251,"endColumn":72},{"ruleId":"169","severity":1,"message":"199","line":423,"column":8,"nodeType":"171","endLine":423,"endColumn":10,"suggestions":"200"},{"ruleId":"163","severity":1,"message":"173","line":1,"column":40,"nodeType":"165","messageId":"166","endLine":1,"endColumn":48},{"ruleId":"163","severity":1,"message":"196","line":22,"column":20,"nodeType":"165","messageId":"166","endLine":22,"endColumn":29},{"ruleId":"163","severity":1,"message":"197","line":22,"column":31,"nodeType":"165","messageId":"166","endLine":22,"endColumn":35},{"ruleId":"169","severity":1,"message":"199","line":37,"column":6,"nodeType":"171","endLine":37,"endColumn":8,"suggestions":"201"},"no-unused-vars","'Header' is defined but never used.","Identifier","unusedVar","'AuthContext' is defined but never used.","'logoutUser' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'updateToken'. Either include it or remove the dependency array.","ArrayExpression",["202"],"'useState' is defined but never used.","'useEffect' is defined but never used.","'useContext' is defined but never used.","'FriendContext' is defined but never used.","'passwordError' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'MainContainer' is defined but never used.","React Hook useEffect has a missing dependency: 'getFriends'. Either include it or remove the dependency array.",["203"],"'FriendListContext' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'getFriendRequest'. Either include it or remove the dependency array.",["204"],"'Navigate' is defined but never used.","'response' is assigned a value but never used.",["205"],"'ConControls' is defined but never used.","The ref value 'containerRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'containerRef.current' to a variable inside the effect, and use that variable in the cleanup function.","React Hook useEffect has missing dependencies: 'getMessages', 'removeFromStorage', 'string', and 'updates'. Either include them or remove the dependency array.",["206"],"'authToken' is assigned a value but never used.","'user' is assigned a value but never used.","'chat' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'handleUserLeft'. Either include it or remove the dependency array.",["207"],["208"],{"desc":"209","fix":"210"},{"desc":"211","fix":"212"},{"desc":"213","fix":"214"},{"desc":"213","fix":"215"},{"desc":"216","fix":"217"},{"desc":"218","fix":"219"},{"desc":"218","fix":"220"},"Update the dependencies array to be: [authToken, loading, WebSocket, updateToken]",{"range":"221","text":"222"},"Update the dependencies array to be: [getFriends]",{"range":"223","text":"224"},"Update the dependencies array to be: [getFriendRequest]",{"range":"225","text":"226"},{"range":"227","text":"226"},"Update the dependencies array to be: [getMessages, removeFromStorage, string, updates, username]",{"range":"228","text":"229"},"Update the dependencies array to be: [handleUserLeft]",{"range":"230","text":"231"},{"range":"232","text":"231"},[5631,5662],"[authToken, loading, WebSocket, updateToken]",[1513,1515],"[getFriends]",[1447,1449],"[getFriendRequest]",[1970,1972],[3271,3281],"[getMessages, removeFromStorage, string, updates, username]",[14978,14980],"[handleUserLeft]",[1088,1090]]