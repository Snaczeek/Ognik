[{"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\index.js":"1","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\App.js":"2","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Header.js":"3","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\AuthContext.js":"4","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\utils\\ProtectedRoute.js":"5","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\MainApp.js":"6","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\HomePage.js":"7","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\LoginPage.js":"8","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\RegisterPage.js":"9","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ChannelListContainer.js":"10","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MainContainer.js":"11","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\FriendContext.js":"12","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendList.js":"13","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Sidebar.js":"14","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendRequestListContainer.js":"15","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\AddFriendContainer.js":"16","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MessageContainer.js":"17","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ConControls.js":"18"},{"size":250,"mtime":1689102107715,"results":"19","hashOfConfig":"20"},{"size":1029,"mtime":1689604513114,"results":"21","hashOfConfig":"20"},{"size":788,"mtime":1689605391395,"results":"22","hashOfConfig":"20"},{"size":5221,"mtime":1689604772805,"results":"23","hashOfConfig":"20"},{"size":412,"mtime":1689100876600,"results":"24","hashOfConfig":"20"},{"size":545,"mtime":1689096982239,"results":"25","hashOfConfig":"20"},{"size":1624,"mtime":1689605361158,"results":"26","hashOfConfig":"20"},{"size":1085,"mtime":1689096982238,"results":"27","hashOfConfig":"20"},{"size":4497,"mtime":1689603166374,"results":"28","hashOfConfig":"20"},{"size":492,"mtime":1689096982227,"results":"29","hashOfConfig":"20"},{"size":1139,"mtime":1689096982231,"results":"30","hashOfConfig":"20"},{"size":1688,"mtime":1689600959195,"results":"31","hashOfConfig":"20"},{"size":702,"mtime":1689096982229,"results":"32","hashOfConfig":"20"},{"size":2698,"mtime":1689600967551,"results":"33","hashOfConfig":"20"},{"size":2729,"mtime":1689600995046,"results":"34","hashOfConfig":"20"},{"size":3497,"mtime":1689601010251,"results":"35","hashOfConfig":"20"},{"size":11778,"mtime":1689602131563,"results":"36","hashOfConfig":"20"},{"size":16992,"mtime":1689096982229,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},"1afarxc",{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45"},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53"},{"filePath":"54","messages":"55","suppressedMessages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"57"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"72"},{"filePath":"73","messages":"74","suppressedMessages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"57"},{"filePath":"77","messages":"78","suppressedMessages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"57"},{"filePath":"81","messages":"82","suppressedMessages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84"},{"filePath":"85","messages":"86","suppressedMessages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88","usedDeprecatedRules":"57"},{"filePath":"89","messages":"90","suppressedMessages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92"},{"filePath":"93","messages":"94","suppressedMessages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96"},{"filePath":"97","messages":"98","suppressedMessages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"100"},{"filePath":"101","messages":"102","suppressedMessages":"103","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104"},{"filePath":"105","messages":"106","suppressedMessages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"57"},"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\index.js",[],[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\App.js",["109","110"],[],"import './App.css';\r\nimport Header from './components/Header';\r\nimport AuthContext, { AuthProvider } from './context/AuthContext';\r\n\r\nimport { Routes, Route, HashRouter  as Router } from 'react-router-dom'\r\nimport ProtectedRoute from './utils/ProtectedRoute'\r\n\r\nimport HomePage from './pages/HomePage';\r\nimport LoginPage from './pages/LoginPage';\r\nimport MainApp from './pages/MainApp';\r\nimport RegisterPage from './pages/RegisterPage';\r\n\r\n\r\nfunction App() {\r\n  // let {user} = useContext(AuthContext)\r\n\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Router >\r\n        <AuthProvider>\r\n          <Routes>\r\n            <Route element={<HomePage />} path=\"/\"/>\r\n            <Route element={<LoginPage />} path=\"/login\"/>\r\n            <Route element={<RegisterPage />} path=\"/register\" />\r\n            <Route element={<ProtectedRoute />}>\r\n              <Route path='/test/*' element={<MainApp />} />\r\n            </Route>\r\n          </Routes>\r\n        </AuthProvider>\r\n      </Router>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Header.js",["111","112"],[],"import React, {useContext} from 'react'\r\nimport { Link } from 'react-router-dom'\r\nimport AuthContext from '../context/AuthContext'\r\n\r\nconst Header = () => {\r\n  let {user, logoutUser} = useContext(AuthContext)\r\n  return (\r\n    <div className='header'>\r\n        <Link to=\"/\">Ognik</Link>\r\n        <a>About</a>\r\n        <a href='https://github.com/Snaczeek/Ognik'>Github</a>\r\n        {user ? (\r\n          <div id='header-login-button'><button><Link to=\"/test/friends\">Open ognik</Link></button></div>\r\n          ): (\r\n            <div id='header-login-button'><Link to=\"/login\"><button>Login</button></Link> </div>\r\n            )}\r\n\r\n        {/* {user && <h1>Hello {user.username}</h1>} */}\r\n        {/* <Link to=\"/register\">Register</Link> */}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Header\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\AuthContext.js",["113"],[],"import { createContext, useState, useEffect } from 'react';\r\nimport jwt_decode from \"jwt-decode\";\r\nimport { useNavigate } from 'react-router-dom'\r\nimport { w3cwebsocket as W3CWebSocket} from 'websocket';\r\n\r\nconst AuthContext = createContext();\r\n\r\nexport default AuthContext\r\n\r\nexport const AuthProvider = ({children}) => {\r\n    \r\n    // Checking if user has token in browser storage\r\n    // if so then, parsing value into json format\r\n    let [authToken, setAuthTokens] = useState(() => localStorage.getItem('authToken') ? JSON.parse(localStorage.getItem('authToken')) : null)\r\n    // decoding jwt token into useable block\r\n    let [user, setUser] = useState(() => localStorage.getItem('authToken') ? jwt_decode(localStorage.getItem('authToken')) : null)\r\n    \r\n    let [loading, setLoading] = useState(true)\r\n    // https://ognik-backend.duckdns.org/\r\n    let url = `wss://ognik-backend.duckdns.org/ws/socket-server/`\r\n    let [WebSocket, setWebSocket] = useState(() => localStorage.getItem('authToken') ? new W3CWebSocket(url + \"?token=\" + String(authToken.access)) : null)\r\n    \r\n    const navigate = useNavigate()\r\n    \r\n    // Must be in try block \r\n    // Because on first load Websocket ist set to NULL so .onclose property doesn't exist \r\n    try{\r\n        // If Websocket connection was interruptedly closed\r\n        // Refresh page \r\n        WebSocket.onclose = () => {\r\n            console.log(\"AuthContext: Websocket Closed\")\r\n            window.location.reload();\r\n        }\r\n    }catch(e){\r\n    \r\n    }\r\n    \r\n    // login function\r\n    let loginUser = async (e ) => {\r\n        e.preventDefault()\r\n        // fetching credentials to django backend\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/token/', {\r\n            method: 'POST',\r\n            headers:{\r\n                'Content-Type':'application/json'\r\n            },\r\n            body:JSON.stringify({'username':e.target.username.value, 'password':e.target.password.value})\r\n        })\r\n        let data = await response.json()\r\n        \r\n        // if response form django is positive \r\n        // saving token data to browser storage (at this point user is logged)\r\n        if(response.status === 200)\r\n        {\r\n            setAuthTokens(data)\r\n            setUser(jwt_decode(data.access))\r\n            if (!WebSocket){\r\n                setWebSocket(new W3CWebSocket(url + \"?token=\" + String(data.access)))\r\n            }\r\n            localStorage.setItem('authToken', JSON.stringify(data))\r\n            navigate('/test/friends')  \r\n            window.location.reload()             \r\n        }\r\n        else\r\n        {\r\n            document.getElementsByClassName('login-error-message')[0].innerHTML = 'Incorrect username or password'\r\n            document.getElementById(\"login-username\").style.borderColor = \"rgb(255, 80, 80)\"   \r\n            document.getElementById(\"login-username\").style.borderWidth = '2px' \r\n            document.getElementById(\"login-password\").style.borderColor = \"rgb(255, 80, 80)\"   \r\n            document.getElementById(\"login-password\").style.borderWidth = '2px' \r\n        }\r\n    }\r\n    \r\n    // logout function\r\n    let logoutUser = () => {\r\n        setAuthTokens(null)\r\n        setUser(null)\r\n        \r\n        // clearing users web storage\r\n        localStorage.removeItem('authToken')\r\n        navigate('/')\r\n    }\r\n    \r\n    // updating access token\r\n    let updateToken = async () => {\r\n        // fetching refresh token to django backend\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/token/refresh/', {\r\n            method: 'POST',\r\n            headers:{\r\n                'Content-Type':'application/json'\r\n            },\r\n            // if refresh token exist, send it\r\n            // if not, send null\r\n            body:JSON.stringify({'refresh': authToken?.refresh})\r\n        })\r\n        let data = await response.json()\r\n\r\n        // saving new tokens\r\n        if (response.status === 200){\r\n            setAuthTokens(data)\r\n            setUser(jwt_decode(data.access))\r\n            localStorage.setItem('authToken', JSON.stringify(data))\r\n        }else\r\n        {\r\n            logoutUser()\r\n        }\r\n        \r\n        if(loading){\r\n            setLoading(false)\r\n        }\r\n    }\r\n    \r\n    // context data for provider\r\n    let contextData = {\r\n        user:user,\r\n        authToken:authToken,\r\n        loginUser:loginUser,\r\n        logoutUser: logoutUser,\r\n        WebSocket:WebSocket,\r\n    }\r\n    \r\n    useEffect(() => {\r\n   \r\n        \r\n        // before children are rendered \r\n        // update token\r\n        if(loading){\r\n            updateToken()\r\n        }\r\n    \r\n\r\n        // run updateToken() every 4 minutes\r\n        let s4Minutes = 1000 * 60 * 4\r\n        let interval = setInterval(() => {\r\n            if(authToken){\r\n                updateToken()\r\n            }\r\n        }, s4Minutes)\r\n        return ()=> clearInterval(interval)\r\n        \r\n    }, [authToken, loading, WebSocket])\r\n    \r\n    // returnig contex data for children\r\n    return (\r\n        <AuthContext.Provider value={contextData}>\r\n        {/* render children after loading is done */}\r\n        {loading ? null : children}\r\n    </AuthContext.Provider>\r\n    );\r\n}","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\utils\\ProtectedRoute.js",[],[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\MainApp.js",["114","115","116","117","118"],[],"import React, {useState, useEffect, useContext} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\nimport FriendContext, {FriendProvider} from '../context/FriendContext'\r\nimport ChannelListContainer from '../components/ChannelListContainer'\r\nimport MainContainer from '../components/MainContainer'\r\n\r\nconst MainApp = () => {\r\n \r\n  return (\r\n    <div className='MainApp'>\r\n      <FriendProvider>\r\n          <ChannelListContainer />\r\n          <MainContainer />\r\n      </FriendProvider>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default MainApp\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\HomePage.js",[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\LoginPage.js",[],[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\pages\\RegisterPage.js",["119","120","121","122"],[],"import React, {useContext} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\n\r\nconst RegisterPage = () => {\r\n    let {loginUser} = useContext(AuthContext)\r\n    let register = async (e) => {\r\n        e.preventDefault()\r\n        // Getting input html objects\r\n        let email = e.target.email\r\n        let nickname = e.target.username\r\n        let password = e.target.password\r\n        let confirmPassword = e.target.confirmPassword\r\n        \r\n        // Getting html error objects\r\n        const emailError = document.getElementById(\"error-email-input\")\r\n        const usernameError = document.getElementById(\"error-username-input\")\r\n        const passwordError = document.getElementById(\"error-password-input\")\r\n        const confirmPasswordError = document.getElementById(\"error-confirm-password-input\")\r\n\r\n        const formData = {\r\n            username: e.target.username.value,\r\n            password: e.target.password.value,\r\n            email: e.target.email.value,\r\n        }\r\n\r\n        // Reseting error \r\n        email.style.borderColor = \"black\"\r\n        nickname.style.borderColor = \"black\"\r\n        password.style.borderColor = \"black\"\r\n        confirmPassword.style.borderColor = \"black\"\r\n\r\n        emailError.innerHTML = \"\"\r\n        usernameError.innerHTML = \"\"\r\n        confirmPasswordError.innerHTML = \"\"\r\n\r\n        // Regex for checking email\r\n        const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n        \r\n\r\n        // Incorrect email\r\n        if (!regex.test(email.value))\r\n        {\r\n            alert(\"incorrect email\")\r\n            email.style.borderColor = \"red\"\r\n            emailError.innerHTML = \"Incorrect email\"\r\n            return\r\n        }\r\n\r\n        // Incorrect password confirm\r\n        if (password.value != confirmPassword.value)\r\n        {\r\n            alert(\"confirm password doesn't match up\")\r\n            password.style.borderColor = \"red\"\r\n            confirmPassword.style.borderColor = \"red\"\r\n            confirmPasswordError.innerHTML = \"Passwords doesn't match\"\r\n            return\r\n        }\r\n\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/register', {\r\n            method: \"POST\",\r\n            headers:{\r\n                'Content-Type':'application/json'\r\n            },\r\n            body: JSON.stringify(formData)\r\n        })\r\n        let data = await response.json()\r\n\r\n        // Incorrect Username\r\n        if (data.error == \"Username already exists\")\r\n        {\r\n            alert(\"Username is already taken\")\r\n            nickname.style.borderColor = \"red\"\r\n            usernameError.innerHTML = \"Username is already taken\"\r\n            return\r\n        }\r\n\r\n        if (data.error == \"Username is too long\")\r\n        {\r\n            nickname.style.borderColor = \"red\"\r\n            usernameError.innerHTML = \"Username is to long\"\r\n            return\r\n        }\r\n        loginUser(e)\r\n    }\r\n\r\n  return (\r\n    <div id='register-page'>\r\n        <div className='island-container'>\r\n            <form onSubmit={register} autoComplete='off' id='register-form'>\r\n                <div className='register-form-inpur-container'>\r\n                    <label>E-mail</label> <br/>\r\n                    <input type=\"text\" id='register-email' name='email' /> <br/>\r\n                    <p id='error-email-input' className='register-error-message'></p>\r\n                </div>\r\n\r\n                <div className='register-form-inpur-container'> \r\n                    <label>Username</label> <br/>\r\n                    <input type=\"text\" id='register-nickname' name='username' /> <br/>\r\n                    <p id='error-username-input' className='register-error-message'></p>\r\n                </div>\r\n\r\n                <div className='register-form-inpur-container'>\r\n                    <label>Password</label> <br/>\r\n                    <input type=\"password\" id='register-password' name='password' /> <br/>\r\n                    <p id='error-password-input' className='register-error-message'></p>\r\n                </div>\r\n\r\n                <div className='register-form-inpur-container'>\r\n                    <label>Confirm Password</label> <br/>\r\n                    <input type=\"password\" id='confirm-register-password' name='confirmPassword' /> <br/>\r\n                    <p id='error-confirm-password-input' className='register-error-message'></p>\r\n                </div>\r\n\r\n                <button>SIGN UP</button>\r\n            </form>   \r\n        </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default RegisterPage",[],"C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ChannelListContainer.js",["123"],[],"import React from 'react'\r\nimport Sidebar from './Sidebar'\r\nimport FriendList from './FriendList'\r\nimport MainContainer from '../components/MainContainer'\r\n\r\nimport { Routes, Route } from 'react-router-dom'\r\n\r\n\r\nexport const ChannelListContainer = () => {\r\n  return (\r\n    <div className=\"ChannelListContainer\">\r\n        <Sidebar />\r\n        <Routes>\r\n          <Route path=\"/friends/*\" element={<FriendList />} />\r\n        </Routes>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default ChannelListContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MainContainer.js",["124","125","126"],[],"import React, {useContext, useState, useEffect} from 'react'\r\nimport MessageContainer from './MessageContainer'\r\nimport AddFriendContainer from './AddFriendContainer'\r\nimport FriendRequestListContainer from './FriendRequestListContainer'\r\n\r\nimport { Routes, Route } from 'react-router-dom'\r\nimport AuthContext from '../context/AuthContext'\r\nimport FriendContext from '../context/FriendContext'\r\nconst MainContainer = () => {\r\n  let {wsdata} = useContext(FriendContext)\r\n  // let {WebSocket} = useContext(AuthContext)\r\n  // let [messageWS, setMessageWS] = useState(null)\r\n\r\n  // WebSocket.onmessage = function (e) {\r\n  //   setMessageWS(e.data)\r\n  // }\r\n  // console.log(\"Main ws listener is working poggers\")\r\n  // console.log(messageWS)\r\n\r\n  return (\r\n    <div className='main_container'>\r\n      <Routes>\r\n        <Route path=\"/friends/mcon/:username\" element={<MessageContainer asd={wsdata}/>} />\r\n        <Route path=\"/friends/addFriend\" element={<AddFriendContainer />} />\r\n        <Route path=\"/friends/friendRequestList\" element={<FriendRequestListContainer />} />\r\n      </Routes>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default MainContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\context\\FriendContext.js",["127"],[],"import React from 'react'\r\nimport { createContext, useState, useEffect, useContext } from 'react';\r\nimport AuthContext from '../context/AuthContext'\r\n\r\n\r\nconst FriendContext = createContext();\r\n\r\nexport default FriendContext\r\n\r\nexport const FriendProvider = ({children}) => {\r\n    let [friends, setFriends] = useState([])\r\n    let {authToken, WebSocket} = useContext(AuthContext) \r\n    let [wsdata, setWsdata] = useState()  \r\n\r\n    WebSocket.onmessage = (e) => {\r\n        let data = JSON.parse(e.data)\r\n        console.log(data)\r\n        setWsdata(data)\r\n        // console.log(wsdata)\r\n        if(data.type === \"friendRequest\")\r\n        {\r\n            getFriends()\r\n            window.location.reload()\r\n        }\r\n    }\r\n\r\n    let getFriends = async () =>{\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/friends/', {\r\n            method: \"GET\",\r\n            headers:{\r\n                'Content-Type':'application/json',\r\n                'Authorization':'Bearer ' + String(authToken.access)\r\n            }\r\n        })\r\n\r\n        let data = await response.json()\r\n        let new_data = []\r\n        \r\n        // pushing only username's to new array\r\n        for (let i = 0; i < data[0].friends.length; i++) {\r\n            // console.log(\"test: \" + data[0].friends[i].username + \" \" + i);\r\n            new_data.push(data[0].friends[i].username)\r\n        }\r\n        setFriends(new_data)\r\n    }\r\n\r\n    useEffect(() => {\r\n        getFriends()\r\n    }, [])\r\n\r\n    let contextData = {\r\n        friends:friends,\r\n        wsdata:wsdata\r\n    }\r\n\r\n  return (\r\n    <FriendContext.Provider value={contextData}>\r\n        {children}\r\n    </FriendContext.Provider>\r\n  )\r\n}\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendList.js",["128","129","130"],[],"import React, {useState, useEffect, useContext, createContext} from 'react'\r\nimport FriendContext from '../context/FriendContext'\r\nimport { Link } from 'react-router-dom';\r\n\r\nconst FriendListContext = createContext();\r\n\r\nexport const FriendList = () => {\r\n\r\n    let {friends} = useContext(FriendContext)\r\n    let i = 0\r\n\r\n  return (\r\n    <div className='friends_list'>\r\n      <Link to={\"./addFriend\"}><div className='add_friend_div'>Add Friend</div></Link>\r\n      <div className='friends_list_title'>Friends list</div>\r\n        {friends.map(f => (\r\n            <Link to={\"./mcon/\"+f} ><div key={i++}className='friends_elem'>{f}</div></Link>\r\n        ))}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default FriendList","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\Sidebar.js",["131"],[],"import React, { useContext, useEffect } from \"react\";\r\nimport HomeIcon from \"../assets/home.png\";\r\nimport LogoutIcon from \"../assets/logout.png\";\r\nimport FriendRequestIcon from \"../assets/notification.png\" ;\r\nimport AuthContext from \"../context/AuthContext\";\r\n\r\nimport { Link } from 'react-router-dom';\r\n\r\n\r\nexport const Sidebar = () => {\r\n\r\n    let { WebSocket, logoutUser, authToken} = useContext(AuthContext)\r\n\r\n    // nie wiem czemu ale nie działa \r\n    WebSocket.onmessage = (e) => {\r\n        let data = JSON.parse(e.data)\r\n        // console.log(data)\r\n        if(data.type === \"friendRequest\")\r\n        {\r\n            getFriendRequest()\r\n            window.location.reload()\r\n        }\r\n    }\r\n\r\n    let getFriendRequest = async () => {\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/friendrequest/getFriendRequest', {\r\n          method: 'GET',\r\n          headers:{\r\n            'Content-Type':'application/json',\r\n            'Authorization':'Bearer ' + String(authToken.access)\r\n          },\r\n        })\r\n        let data = await response.json()\r\n        // console.log(data.length)\r\n        if (data.length !== 0)\r\n        {\r\n            // console.log(\"Debug Show Red Dot\")\r\n            document.getElementById(\"red_circle\").removeAttribute(\"hidden\");\r\n        }\r\n        else\r\n        {\r\n            // console.log(\"empty\")\r\n            document.getElementById(\"red_circle\").setAttribute(\"hidden\", \"\")\r\n        }\r\n      }\r\n\r\n      useEffect(() => {\r\n        getFriendRequest()\r\n      }, [])\r\n\r\n      let exit = async () => {\r\n        logoutUser()\r\n        // const delay = ms => new Promise(\r\n        //     resolve => setTimeout(resolve, ms)\r\n        // );\r\n        // await delay(1000)\r\n        // window.location.reload()\r\n        \r\n      }\r\n\r\n    return (\r\n        <div className=\"sidebar\">\r\n            <div className=\"sidebar_home-icon\">\r\n                <div className=\"home-icon_inner\">\r\n                    <Link to=\"./friends\"><img src={HomeIcon} alt=\"home\" /></Link>\r\n                </div>\r\n            </div>\r\n            <div className=\"sidebar_FriendRequestIcon-icon\">\r\n                <div className=\"home-icon_inner\">\r\n                    <Link to=\"./friends/friendRequestList\"><img src={FriendRequestIcon} alt=\"friend_request\"  /></Link>\r\n                </div>\r\n                <div className=\"red_circle\" hidden id=\"red_circle\"></div>\r\n            </div>\r\n            <div className=\"sidebar_logout-icon\">\r\n                <div className=\"logout-icon_inner\">\r\n                    <img onClick={exit} src={LogoutIcon} alt=\"home\" width={30}/>\r\n                </div>\r\n            </div>\r\n        </div>\r\n  )\r\n}\r\n\r\nexport default Sidebar;","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\FriendRequestListContainer.js",["132","133","134","135"],[],"import React, {useState, useEffect, useContext, Navigate} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\n// import FriendContext from '../context/FriendContext'\r\n\r\nconst FriendRequestListContainer = () => {\r\n\r\n  let [friendRequest, setfriendRequest] = useState([])\r\n  let { WebSocket, authToken} = useContext(AuthContext) \r\n  \r\n    // WebSocket.onmessage = function (e) {\r\n    //     let data = JSON.parse(e.data)\r\n    //     if(data.type == \"friendRequest\")\r\n    //     {\r\n    //         setTimeout(() => {\r\n    //             getFriendRequest()\r\n    //           }, 100);\r\n    //     }\r\n    //     // console.log(WSdata)\r\n    // }\r\n\r\n  let getFriendRequest = async () => {\r\n    let response = await fetch('https://ognik-backend.duckdns.org/users/friendrequest/getFriendRequest', {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      },\r\n    })\r\n    let data = await response.json()\r\n    console.log(data)\r\n    setfriendRequest(data)\r\n  }\r\n\r\n  let acceptFriendRequest = async (username) => {\r\n    let response = await fetch('https://ognik-backend.duckdns.org/users/friendrequest/acceptFriendRequest/' + username, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      },\r\n    })\r\n    window.location.reload()\r\n    WebSocket.send(JSON.stringify({\r\n      'friendName': username,\r\n      'type': 'friend_request',\r\n  }))\r\n  }\r\n\r\n  let declineFriendRequest = async (username) => {\r\n    let response = await fetch('https://ognik-backend.duckdns.org/users/friendrequest/declineFriendRequest/' + username, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      },\r\n    })\r\n    getFriendRequest()\r\n  }\r\n\r\n  useEffect(() => {\r\n    getFriendRequest()\r\n  }, [])\r\n\r\n  return (\r\n    <div className='friendrequest_container'>\r\n        <h1>Your friend requests are here!</h1>\r\n        <div className='friend_request_list'>\r\n          {friendRequest.map(r => (\r\n            <div className='friend_request_elem'>\r\n                <p1>{r.sender[\"username\"]}</p1>\r\n                <div className='friend_request_elem_buttons'>\r\n                  <button id=\"friend_request_acpt_button\" onClick={() => acceptFriendRequest(r.sender[\"username\"])}>Accept</button>\r\n                  <button id=\"friend_request_dec_button\" onClick={() => declineFriendRequest(r.sender[\"username\"])}>Decline</button>\r\n                </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default FriendRequestListContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\AddFriendContainer.js",["136"],[],"import React, {useState, useEffect, useContext} from 'react'\r\nimport AuthContext from '../context/AuthContext'\r\nimport FriendContext from '../context/FriendContext'\r\n\r\nconst AddFriendContainer = () => {\r\n\r\n    let [users, setUsers] = useState([])\r\n    let { WebSocket, authToken} = useContext(AuthContext)\r\n    let {friends} = useContext(FriendContext)\r\n    // friend_search\r\n    let getUesrs = async (e) => {\r\n        e.preventDefault();\r\n        // alert(document.getElementById('friend_search').value);\r\n        let username = document.getElementById('friend_search').value\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/friendrequest/getUsers/'+ username, {\r\n            method: 'GET',\r\n            headers:{\r\n                'Content-Type':'application/json',\r\n                'Authorization':'Bearer ' + String(authToken.access)\r\n            },\r\n        })\r\n        let data = await response.json()\r\n        setUsers(data)\r\n        console.log(Object.keys(data))\r\n        if (Object.keys(data).length === 0){\r\n            // console.log(\"worky\")\r\n            document.getElementById(\"friend_text\").innerHTML = \"Account not found\"\r\n        } \r\n        else{\r\n            document.getElementById(\"friend_text\").innerHTML = \"\"\r\n        }\r\n    }\r\n\r\n    let sendFriendRequest = async (username) => {\r\n        // ToDo Send Friend request using http post and websocket\r\n        alert(username)\r\n\r\n        //  friendrequest/sendFriendRequest/<str:friendName>\r\n        let response = await fetch('https://ognik-backend.duckdns.org/users/friendrequest/sendFriendRequest/'+ username, {\r\n            method: 'GET',\r\n            headers:{\r\n                'Content-Type':'application/json',\r\n                'Authorization':'Bearer ' + String(authToken.access)\r\n            },\r\n        })\r\n        let data = await response.json()\r\n        console.log(data.status)\r\n        if (data.status === \"already exist\"){\r\n            alert(\"Friend request was already sended\")\r\n        }\r\n        else\r\n        {\r\n            // Sending message to websocket (so that receivee can see friend request apear in real time)\r\n            WebSocket.send(JSON.stringify({\r\n                'friendName': username,\r\n                'type': 'friend_request',\r\n            }))\r\n        }\r\n    }\r\n\r\n\r\n  return (\r\n    <div className='friendadd_container'>\r\n        <div className='friend_header_container'>\r\n            <h1>You can add friends by searching their username</h1> <br/>\r\n            <form onSubmit={getUesrs} className=\"friend_search\" autoComplete=\"off\"> \r\n                <input type=\"text\" id=\"friend_search\" placeholder=\"username\"/>\r\n                <button type=\"submit\">Search</button>\r\n            </form>\r\n        </div>\r\n            \r\n        <ul className=\"friendadd_list\">\r\n            {/* <p1 id=\"friend_text\">Looking for a friend?</p1> */}\r\n            {users.map(user => (\r\n                <div className=\"friend_container\">\r\n                    <text className='friend_container_username'>{user.username}</text>\r\n                    {friends.includes(user.username) ? (\r\n                        <text className=\"friend_container_UFWTP\">You're friends with this person</text>\r\n                    ): (\r\n                        <button onClick={() => sendFriendRequest(user.username)}>Send Friend Request</button>\r\n                    )}\r\n                    \r\n                </div>\r\n            ))}\r\n        </ul>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default AddFriendContainer","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\MessageContainer.js",["137","138","139","140","141","142"],[],"import React, {useState, useEffect, useContext, useRef}  from 'react'\r\nimport {  useParams } from \"react-router-dom\";\r\nimport AuthContext from '../context/AuthContext'\r\nimport ConControls from './ConControls';\r\n\r\n\r\nconst MessageContainer = () => {\r\n  let [messageRTC, setMessageRTC] = useState(null)\r\n  \r\n  // Getting username from URL\r\n  let { username } = useParams();\r\n  let string = username.toString()\r\n\r\n\r\n  const containerRef = useRef(null)\r\n\r\n  // Creating messages var \r\n  // Getting messages from session storage for current friend\r\n  // If session storage doesnt have any values it means:\r\n  // 1: Theres is no messages in current chatroom\r\n  // 2: or it is first load of chatroom\r\n  // in any cases above, chatroom will send to django getMessages request\r\n  let [messages, setMessages] = useState([]) \r\n  \r\n  let newestMessage = useRef({})\r\n  let oldestMessage = useRef({})\r\n\r\n  // CurrentMessages contains messages from every friend that were loaded in current session\r\n  let currentMessages = useRef({})\r\n\r\n  let { WebSocket, authToken, user} = useContext(AuthContext)\r\n  \r\n  // Initializint empty list\r\n  let updates = []\r\n  // Checking if key 'update' exist in session storage\r\n  // If not:\r\n  if (sessionStorage.getItem(\"Updates\") == null)\r\n  {\r\n    // Creating Key with empty list as value\r\n    sessionStorage.setItem(\"Updates\", JSON.stringify(updates))\r\n  } \r\n  // Updating list with current values from session storage\r\n  // so that list is up to date\r\n  updates = sessionStorage.getItem(\"Updates\")\r\n\r\n  // functions 'useEffect()' trigges on the first load\r\n  // and every time 'username' is updated \r\n  useEffect(() => {\r\n    \r\n\r\n    if (!currentMessages.current[`${string}`])\r\n    {\r\n      currentMessages.current[`${string}`] = [];\r\n    }\r\n\r\n    // Checking if messages are empty\r\n    if (currentMessages.current[`${string}`].length == 0)\r\n    {\r\n      // If so, sending to django reqeust for new messages from database\r\n      getMessages(40, \"321\" ,1)\r\n    }\r\n    else if(updates.includes(username))\r\n    {\r\n      // If not and update list contains friend username\r\n      // It means friend send to this user message\r\n      // and message var needs to be updated \r\n\r\n      // Removing friend from update list\r\n      removeFromStorage(username)\r\n      // Getting new messages \r\n      // (In Future there should be update function that will only get new messages, instead getting all messages from current chatroom) DONE\r\n      getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n    }\r\n    else\r\n    {\r\n      // else it means there was no updates/messages sent\r\n      // so setting messages from currentMessages ref, stored before\r\n      setMessages(currentMessages.current[`${string}`])\r\n    }\r\n\r\n    // \r\n    const handleScroll = () => {\r\n      if (containerRef.current.scrollTop === 0) {\r\n        getMessages(40, oldestMessage.current[`${string}`].created, 3, 2)\r\n      }\r\n    };\r\n\r\n    containerRef.current.addEventListener('scroll', handleScroll);\r\n\r\n    return () => {\r\n      if (containerRef.current){\r\n        containerRef.current.removeEventListener('scroll', handleScroll);\r\n      }\r\n    };\r\n\r\n  }, [username])\r\n  \r\n  WebSocket.onclose = () => {\r\n    console.log(\"Websocket Client Disconnected\");\r\n  }\r\n\r\n  WebSocket.onopen = () => {\r\n    console.log('WebSocket Client Connected');\r\n    WebSocket.send(JSON.stringify({\r\n      'message': 'friend is connected',\r\n      'friendName': string,\r\n      'type': 'message_update',\r\n    }))\r\n  }\r\n  // Listener for upcoming messages from django\r\n  // I dont think async is required, but who knows \r\n  WebSocket.onmessage = function (e) {\r\n    let data = JSON.parse(e.data)\r\n    // Console logging messages for debugging\r\n    // console.log('Data:', data)\r\n    // console.log(JSON.parse(e.data))\r\n    if(data.type === 'friendRequest' && data.friend != user.username)\r\n    {\r\n      window.location.reload()\r\n    }\r\n    // If user recives chat_update prompt and is from a friend \r\n    // whos chatroom is open: update messages \r\n    if(data.type === 'chat_update' && data.friend === string){\r\n      // console.log('chat')\r\n      // 100ms delay is required, for some bizarre reasons\r\n      // if there is no delay, getMessages() works every 3rd time\r\n      setTimeout(() => {\r\n        if (newestMessage.current[`${string}`])\r\n        {\r\n          getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n        }\r\n        else\r\n        {\r\n          getMessages(10, \"321\" ,1)\r\n        }\r\n      }, 300);\r\n      // setMessageRTC(data)\r\n      // isCalling(true)\r\n    }\r\n    else if (!updates.includes(data.friend) && data.friend !== user.username)\r\n    {\r\n        // If friend sent you messages \r\n        // and that friends chatroom wasnt open\r\n        // saving that friend username to update list \r\n        pushToStorage(data.friend);          \r\n    }\r\n    else //if(data.type === \"init_call\" && data.friend === string)\r\n    {\r\n      // console.log(\"Your friends is calling\")\r\n      setMessageRTC(data)\r\n      // isCalling(true)\r\n      // isFcall(true)\r\n    }\r\n  }\r\n  // Getting messages form django backend\r\n  let getMessages = async (count = 1, date = \"1987-07-18T20:59:26.076557Z\", mode = 1, mode2 = 1) => {\r\n    let respone = await fetch(`https://ognik-backend.duckdns.org/users/rooms/${string}/${count}/${date}/${mode}`, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      }\r\n    }, [])\r\n    \r\n    let data = await respone.json()\r\n    // console.log(data)\r\n    \r\n    // console.log(currentMessages.current)\r\n    // console.log(currentMessages.current[`${string}`])\r\n    \r\n    // Adding messages to currentMessage ref\r\n    addToMessages(data, mode2)\r\n    \r\n    // \r\n    setMessages(currentMessages.current[`${string}`])\r\n    // console.log(\"newest: \" + newestMessage.current[`${string}`].created)\r\n    // console.log(\"oldest: \" + oldestMessage.current[`${string}`].created)\r\n  }\r\n  \r\n  // Function that adds messages to storage and \r\n  // Keep track of newest and oldest messages\r\n  let addToMessages = (data, mode = 1) => {\r\n    \r\n    // Adding new message/s to ref \r\n    // mode 1 adding ms at the beginning of the list\r\n    // mode 2 adding ms at the end of the list\r\n    if (mode == 1)\r\n    {\r\n      currentMessages.current[`${string}`] = [...currentMessages.current[string], ...data];\r\n    }\r\n    else if (mode == 2)\r\n    {\r\n      currentMessages.current[`${string}`] = [...data, ...currentMessages.current[string]];\r\n    }\r\n    \r\n    newestMessage.current[`${string}`] = currentMessages.current[`${string}`][currentMessages.current[`${string}`].length - 1];\r\n    oldestMessage.current[`${string}`] = currentMessages.current[`${string}`][0];\r\n  }\r\n\r\n  \r\n  // Sending messages to djnago\r\n  let sendMessage = async (e) => {\r\n    e.preventDefault()\r\n    // Sending message to websocket\r\n    // And passing friend name from url\r\n    await fetch('https://ognik-backend.duckdns.org/users/rooms/send/'+string, {\r\n      method: 'POST',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      }, \r\n      body:JSON.stringify(e.target.message.value)\r\n    })\r\n    WebSocket.send(JSON.stringify({\r\n      'message': 'message was sent',\r\n      'friendName': string,\r\n      'type': 'message_update',\r\n    }))\r\n    document.getElementById('mess').value = ''\r\n    \r\n    // Checking if message exist in chatroom\r\n    if (newestMessage.current[`${string}`])\r\n    {\r\n      getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n    }\r\n    else\r\n    {\r\n      getMessages(10, \"321\" ,1)\r\n    }\r\n\r\n  }\r\n\r\n  let getCSRFToken = async () => {\r\n    let response = await fetch(`https://ognik-backend.duckdns.org/users/get-csrf-token`, {\r\n      method: 'GET',\r\n      headers:{\r\n        'Content-Type':'application/json',\r\n        'Authorization':'Bearer ' + String(authToken.access)\r\n      }\r\n    }, [])\r\n    let data = await response.json()\r\n    // console.log(data)\r\n    return data.csrfToken;\r\n  }\r\n\r\n  let uploadFile = async (e) => {\r\n    // Getting token as far as I know is not currently requierd\r\n    const csrfToken = await getCSRFToken()\r\n    // Getting file from html input\r\n    const file = e.target.files[0];\r\n\r\n    // Creating form object\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    formData.append('csrfmiddlewaretoken', csrfToken);\r\n\r\n    await fetch('https://ognik-backend.duckdns.org/users/rooms/sendfile/'+string, {\r\n      method: 'POST',\r\n      headers:{\r\n        // 'Content-Type':'multipart/form-data',\r\n        'Authorization':'Bearer ' + String(authToken.access),\r\n        'X-CSRFToken': csrfToken\r\n        // 'Access-Control-Allow-Origin': 'origin-or-null / wildcard'\r\n      }, \r\n      body: formData\r\n    })\r\n\r\n    document.getElementById('file_input').value = null\r\n\r\n    WebSocket.send(JSON.stringify({\r\n      'message': 'message was sent',\r\n      'friendName': string,\r\n      'type': 'message_update',\r\n    }))\r\n\r\n    getMessages(20, newestMessage.current[`${string}`].created, 2)\r\n  }\r\n\r\n  let downloadFile = (id) => {\r\n    window.open(`https://ognik-backend.duckdns.org/users/rooms/download/${id}/${authToken.access}`, '_blank').focus()\r\n  }\r\n\r\n  function pushToStorage(value)\r\n  {\r\n    // Getting values from storage\r\n    let array = JSON.parse(sessionStorage.getItem(\"Updates\"))\r\n    // Adding value to array\r\n    array.push(value)\r\n    updates = array\r\n    // Overwrites current session storage with new one\r\n    sessionStorage.setItem(\"Updates\", JSON.stringify(array))\r\n  }\r\n\r\n  function removeFromStorage(value)\r\n  {\r\n    // getting data from session storage \r\n    let array = JSON.parse(sessionStorage.getItem(\"Updates\"))\r\n    // Getting index value of passed value (param)\r\n    let index = array.indexOf(value)\r\n    // If value exist in list\r\n    if (index > -1)\r\n    {\r\n      // Removing that value from list\r\n      array.splice(index, 1)\r\n    }\r\n    // Updating 'update' list and saving it to session storage too \r\n    updates = array\r\n    sessionStorage.setItem(\"Updates\", JSON.stringify(array))\r\n  }\r\n\r\n  // setTimeout(() => {\r\n  //     const input = document.getElementById(\"mess\");\r\n  //     input.focus();\r\n  //   }, 10);\r\n\r\n  let FileLinkComponent = (message) => {\r\n    // console.log(message.message.file.fileName)\r\n    return (\r\n      <div className='chat_elem'><div className='inline-flex'>{message.message.user.username}: <div className='file_elem' onClick={() => downloadFile(message.message.file.id) }>{message.message.file.fileName}</div></div></div>\r\n    )\r\n  }\r\n\r\n  function MessageForRender()\r\n  {\r\n    if (messages === null)\r\n    {\r\n      return <h1>No Messages</h1>\r\n    }\r\n    else\r\n    {\r\n      return( \r\n        messages.map(f => f.isIncludeFile === false ? (<div className='chat_elem'>{f.user.username}: {f.body}</div>) : (<FileLinkComponent message={f}/>))\r\n      )\r\n    }\r\n  }\r\n  return (\r\n    <div className='message_container'>\r\n      <div className='message_container_ui'>\r\n        <ConControls data={messageRTC} />\r\n      </div>\r\n      <div className='message_container_chat'>\r\n        <ul className='message_list' ref={containerRef}>\r\n          <MessageForRender  />\r\n        </ul>\r\n        <div className='message_text_input'>\r\n          <form onSubmit={sendMessage} autoComplete=\"off\">\r\n            <input type=\"text\" id='mess' name=\"message\" autoFocus placeholder='type here'/>\r\n            <label id='message_text_input-file' >\r\n              <input type=\"file\" id=\"file_input\" name=\"file\" onChange={uploadFile}/>\r\n              Upload\r\n            </label>\r\n            <button type=\"submit\">Send</button>\r\n          </form>\r\n        </div>\r\n      </div>\r\n      \r\n    </div>\r\n  )\r\n}\r\n\r\nexport default MessageContainer\r\n","C:\\Users\\mateu\\Desktop\\OGNIK\\Ognik\\frontend\\src\\components\\ConControls.js",["143","144","145","146","147","148","149","150","151","152","153","154"],[],"import {React, useEffect, useContext, useState} from 'react'\r\nimport {  useParams } from \"react-router-dom\";\r\nimport CallIcon from \"../assets/phone-call.png\"\r\nimport CameraIcon from \"../assets/camera.png\"\r\nimport MicIcon from \"../assets/mic.png\"\r\nimport PhoneIcon from \"../assets/phone.png\"\r\nimport EndCall from \"../assets/end-call.png\"\r\nimport AuthContext from '../context/AuthContext'\r\n\r\nlet localStream;\r\nlet remoteStream;\r\nlet peerConnection\r\nlet isVisible = false\r\nlet is_in_call = false;\r\nlet friend_call = \"none\"\r\nlet isCalling = false\r\n\r\nconst ConControls = ({data = null, fcall}) => {\r\n    // Getting username from URL\r\n    let { username } = useParams();\r\n    let string = username.toString();\r\n\r\n    // const [isVisible, setIsVisible] = useState(false);\r\n\r\n    // Getting access to authToken and WebSocket info from AuthContext\r\n    let { WebSocket, authToken, user} = useContext(AuthContext)\r\n\r\n    // !!! prop for sending ice can using webSockets !!!\r\n    \r\n    // WebSocket.send(JSON.stringify({\r\n    //     'message': 'message was sent',\r\n    //     'friendName': string,\r\n    //     'type': 'init_call',\r\n    // }))\r\n\r\n\r\n\r\n    const servers = \r\n    {\r\n        iceServers:[\r\n            {\r\n                urls:['stun:stun.l.google.com:19302', 'stun:stun2.l.google.com:19302']\r\n            }\r\n        ]\r\n    } \r\n    \r\n\r\n    let setup_ui = async () => {\r\n        console.log(\"test1\")\r\n        // Getting UI element    \r\n        // let callBTN = document.getElementById(\"call-controls\");\r\n        let button = document.getElementById(\"ConControls-Call-icon\");\r\n        button.style.visibility = \"hidden\";\r\n        // Getting chat element\r\n        let chat = document.getElementsByClassName(\"message_container_chat\")[0];\r\n        let message_list = document.getElementsByClassName(\"message_list\")[0];\r\n        \r\n        // Getting video elemnt\r\n        let user1 = document.getElementById('user-1');\r\n        let user2 = document.getElementById('user-2');\r\n\r\n        // Getting permisson from the user\r\n        localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true}); // getting problem here\r\n\r\n        console.log('test2')\r\n\r\n        let video_container = document.getElementById(\"video_container\");\r\n        video_container.style.display = \"grid\"\r\n\r\n        // Setting up video container style\r\n        // callBTN.style.display = 'visible';\r\n        user1.style.visibility = 'visible';\r\n        user1.style.height = \"100%\";\r\n        user2.style.visibility = 'visible';\r\n        user2.style.height = \"100%\";\r\n        isVisible = true\r\n        // Setting up src stream for user 1\r\n        user1.srcObject = localStream;\r\n        \r\n        user1.onloadedmetadata = function(e) {\r\n            user1.play();\r\n        };\r\n\r\n        // uiNav.style.height = \"50vh\";\r\n        // chat.style.height = \"45vh\";\r\n        message_list.style.height = \"50vh\";\r\n\r\n        is_in_call = true;\r\n    }\r\n\r\n    // Changing layout of website\r\n    let init_call = async () =>\r\n    {\r\n        friend_call = string\r\n        setup_ui()\r\n\r\n        create_offer()\r\n        \r\n        // alert(\"ended\");\r\n    }\r\n\r\n    let createPeerConnection = async () => {\r\n        // Creating connection object\r\n        peerConnection = new RTCPeerConnection(servers)\r\n\r\n        // Creating friend's stream object\r\n        remoteStream = new MediaStream()\r\n        // Setting html video object to friend's stream\r\n        document.getElementById('user-2').srcObject = remoteStream;\r\n\r\n        if(!localStream){\r\n            localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true})\r\n            document.getElementById('user-1').srcObject = localStream\r\n        }\r\n\r\n        // For every track, tracks are added to localStream (user's stream)\r\n        localStream.getTracks().forEach((track) => {\r\n            peerConnection.addTrack(track, localStream)\r\n        })\r\n\r\n        // For every track from friend's peer connection, tracks are added to remoteStream (Friend's stream)\r\n        peerConnection.ontrack = (e) => {\r\n            e.streams[0].getTracks().forEach((track) => {\r\n                remoteStream.addTrack(track)\r\n            })\r\n        }\r\n\r\n        // Debuging\r\n        peerConnection.onicecandidate = async (e) => {\r\n            if(e.candidate){\r\n                // console.log('New ICE candidate: ', e.candidate)\r\n                WebSocket.send(JSON.stringify({\r\n                    'message': e.candidate,\r\n                    'friendName': string,\r\n                    'type': 'candidate',\r\n                }))\r\n            }\r\n        }\r\n    }\r\n\r\n    let create_offer = async () => \r\n    {\r\n        await createPeerConnection()\r\n\r\n        let offer = await peerConnection.createOffer()\r\n        // sets local descirpiton and also fires of peerConnection.onicecandidate listener\r\n        await peerConnection.setLocalDescription(offer)\r\n\r\n        const delay = ms => new Promise(\r\n            resolve => setTimeout(resolve, ms)\r\n        );\r\n        await delay(200)\r\n\r\n        WebSocket.send(JSON.stringify({\r\n            'message': offer,\r\n            'friendName': string,\r\n            'type': 'init_call',\r\n        }))\r\n        // console.log('Offer: ', offer)\r\n        // console.log(peerConnection)\r\n    }\r\n\r\n    let create_answer = async (offer) => {\r\n        await createPeerConnection()\r\n\r\n        await peerConnection.setRemoteDescription(offer)\r\n\r\n        let answer = await peerConnection.createAnswer()\r\n        await peerConnection.setLocalDescription(answer)\r\n\r\n        // console.log(string)\r\n        console.log(\"asnwer: |\")\r\n        console.log(answer)\r\n        // creating delay to ensure that aswer is created before sending message\r\n        // if not first init of the call wont work :( (I have absolutely no idea how to fix this)\r\n        const delay = ms => new Promise(\r\n            resolve => setTimeout(resolve, ms)\r\n        );\r\n        await delay(400)\r\n        WebSocket.send(JSON.stringify({\r\n            'message': answer,\r\n            'friendName': string,\r\n            'type': 'answer',\r\n        }))\r\n\r\n    }\r\n\r\n    let addAnswer = async (answer) => {\r\n        // console.log(\"tests: \")\r\n        // console.log(peerConnection)\r\n        if (!peerConnection.currentRemoteDescription) {\r\n            // console.log(peerConnection) \r\n            console.log(peerConnection.currentRemoteDescription)\r\n            // count++\r\n            await peerConnection.setRemoteDescription(answer);\r\n        }\r\n      };\r\n\r\n    let handleCallFromPeer = async (data) => {\r\n        // quick delay hack (not working in this case :( i hate life )\r\n        // const delay = ms => new Promise(\r\n        //     resolve => setTimeout(resolve, ms)\r\n        // );\r\n        // await delay(300)\r\n        if (data)\r\n        {\r\n            // Debuggin stuff\r\n            // if (data.friend == string)\r\n            // {\r\n                // console.log(data)\r\n            // }\r\n            // If data is type init_call and was send from a friend\r\n            if (data.type == \"init_call\" && data.friend == string)\r\n            {\r\n                // Setting flag that will fire off ui calling prompt\r\n                isCalling = true\r\n                // Getting accept_call button and adding event listener onclick \r\n                // that will fire of createReqeust function with passed 'data' param\r\n                let button = document.getElementById(\"call_request_accept_call\")\r\n                button.addEventListener(\"click\", createRequest)\r\n                button.myParam = data\r\n            }\r\n            \r\n            if (data.message.type === \"answer\" && data.friend == string)\r\n            {\r\n                // Adding answer\r\n                addAnswer(data.message)\r\n                // console.log(\"add_answer\")\r\n                // console.log(data.message)\r\n            }\r\n            \r\n            if (data.type == \"candidate\" && data.friend == string)\r\n            {\r\n                // creating delay hack to ensure that create_answer() sends answer object first via websocket\r\n                // possible fix:\r\n                // create system where peer has to accept call and this will ensure time buffer betweem adding Ice Candidates and receiving answer object\r\n                // answer object must be received before adding any Ice Candidates if not Ice Candidates on peer side will be added to null local description (that will throw error)\r\n                const delay = ms => new Promise(\r\n                    resolve => setTimeout(resolve, ms)\r\n                );\r\n                await delay(1000)\r\n                console.log(\"ice tests\")\r\n                if(peerConnection){\r\n                    console.log(peerConnection.remoteDescription)\r\n                    peerConnection.addIceCandidate(data.message)\r\n\r\n                    console.log(\"addIceCandidate\")\r\n                }\r\n            }\r\n\r\n            if (data.type == \"end_call\" && is_in_call && friend_call == data.friend)\r\n            {\r\n                handleUserLeft()\r\n            }\r\n        }\r\n\r\n        // isCalling(false)\r\n    }\r\n    \r\n    // Creating positive answer to call \r\n    let createRequest = async (data) => {\r\n\r\n        // Saving friend name that user is in call with to var\r\n        friend_call = data.currentTarget.myParam.friend\r\n        // Changing ui \r\n        setup_ui()\r\n        // Creating answer ice object and sending it to a peer \r\n        create_answer(data.currentTarget.myParam.message)\r\n        \r\n        // Making ui call request disappear\r\n        isCalling = false\r\n    }\r\n\r\n    // TO FIX: object stream bug, in new call\r\n    let handleUserLeft = async () => {\r\n        \r\n        // Getting html element\r\n        let uiNav = document.getElementsByClassName(\"ConControls\")[0];\r\n        // Getting whole div that contains input message and list message\r\n        let chat = document.getElementsByClassName(\"message_container_chat\")[0];\r\n        // Getting list that contains messages\r\n        let message_list = document.getElementsByClassName(\"message_list\")[0];\r\n\r\n        // Changing back height setting\r\n        uiNav.style.height = \"auto\";\r\n        chat.style.height = \"auto\";\r\n        // Setting message list to 85% of website height\r\n        message_list.style.height = \"85vh\";\r\n        \r\n        // Getting html call button (green button that init the call)\r\n        let button = document.getElementById(\"ConControls-Call-icon\");\r\n        // Making button visible again\r\n        button.style.visibility = \"visible\";\r\n        \r\n        // Making div that contains video objects invisible\r\n        let video_container = document.getElementById(\"video_container\");\r\n        video_container.style.display = \"none\"\r\n        \r\n        // Getting users video objects\r\n        let user1 = document.getElementById('user-1');\r\n        let user2 = document.getElementById('user-2');\r\n        \r\n        // Making them also invinsible \r\n        user1.style.visibility = 'hidden';\r\n        user1.style.height = \"0%\";\r\n        user2.style.visibility = 'hidden';\r\n        user2.style.height = \"0%\";\r\n        \r\n        // Setting flags to false\r\n        isVisible = false\r\n        is_in_call = false\r\n        isCalling = false\r\n        \r\n        // Testing/debuggin/fixing bugs\r\n\r\n        // localStream.getTracks().forEach((track) => {\r\n            //     track.stop();\r\n            // })\r\n\r\n        // For every track, tracks are added to localStream (user's stream)\r\n        \r\n    \r\n        // console.log(peerConnection.getSenders())\r\n        // peerConnection.removeTrack(peerConnection.getSenders()[0])\r\n\r\n        // let videoTrack = localStream.getTracks().find(track => track.kind === 'video')\r\n        // localStream.getTracks().forEach((track) => {\r\n        //     console.log(track)\r\n        //     // track.stop();\r\n        //     localStream.removeTrack(track)\r\n        // })\r\n\r\n        // closing peer connection (sets connection to 'close' status, it doesn't destroying connection)\r\n        peerConnection.close()\r\n        // Temporary fix to object stream bug\r\n        window.location.reload()\r\n        // removeTrack()\r\n        \r\n        // Sending to peer 'end_call' prompt\r\n        WebSocket.send(JSON.stringify({\r\n            'message': 'end call',\r\n            'friendName': string,\r\n            'type': 'end_call',\r\n        }))\r\n    }\r\n\r\n    // Denying incoming call\r\n    let deny_call = () => {\r\n        isCalling = false\r\n\r\n        // Sending to peer 'end_call' prompt \r\n        WebSocket.send(JSON.stringify({\r\n            'message': 'end call',\r\n            'friendName': string,\r\n            'type': 'end_call',\r\n        }))\r\n    }\r\n\r\n    // Toggle user's stream camera\r\n    let toggle_camera = async () => {\r\n        // Getting user's stream object\r\n        let videoTrack = localStream.getTracks().find(track => track.kind === 'video')\r\n\r\n        if (videoTrack.enabled)\r\n        {\r\n            // Disabling video src\r\n            videoTrack.enabled = false\r\n            // Setting background color of button to red\r\n            document.getElementById('camera_btn').style.backgroundColor = 'rgb(255, 80, 80)'\r\n        }\r\n        else\r\n        {\r\n            // Enabling video src\r\n            videoTrack.enabled = true\r\n            // Setting background color of button to blue\r\n            document.getElementById('camera_btn').style.backgroundColor = 'rgb(102, 153, 255, .8)'\r\n        }\r\n    }\r\n\r\n    // Taggle user's stream audio\r\n    let toggle_audio = async () => {\r\n        // Getting user's stream object\r\n        let audioTrack = localStream.getTracks().find(track => track.kind === 'audio')\r\n\r\n        if (audioTrack.enabled)\r\n        {\r\n            // Disabling audio src\r\n            audioTrack.enabled = false\r\n            // Changing button background to red\r\n            document.getElementById('mic_btn').style.backgroundColor = 'rgb(255, 80, 80)'\r\n        }\r\n        else\r\n        {\r\n            // Enabling audio src\r\n            audioTrack.enabled = true\r\n            // Changing button background to blue\r\n            document.getElementById('mic_btn').style.backgroundColor = 'rgb(102, 153, 255, .8)'\r\n        }\r\n    }\r\n    \r\n    \r\n    useEffect(()=> {\r\n        // Adding event listenr that checks if user refreshed/close tab\r\n        window.addEventListener('beforeunload', handleUserLeft)\r\n        // if(is_in_call === true)\r\n        // {\r\n        //     init_call()\r\n        // }\r\n        // else\r\n        // {\r\n        //     // Getting UI element    \r\n        //     let uiNav = document.getElementsByClassName(\"ConControls\")[0];\r\n        //     // Getting chat element\r\n        //     let chat = document.getElementsByClassName(\"message_container_chat\")[0];\r\n        //     let message_list = document.getElementsByClassName(\"message_list\")[0];\r\n        //     uiNav.style.height = \"auto\";\r\n        //     chat.style.height = \"auto\";\r\n        //     message_list.style.height = \"85vh\";\r\n        // }\r\n        // // setup_ui()\r\n\r\n        // setIsVisible(false)\r\n    }, [])\r\n\r\n    // Logic for handling incoming call from ws\r\n    handleCallFromPeer(data)\r\n    \r\n    return (\r\n        <div className='main_uivideo_con'>\r\n            <div className='ConControls'>\r\n                <div id='ConControls-friendname'>{username}</div>\r\n                <div id='ConControls-Call-icon' onClick={init_call}><img src={CallIcon} alt=\"call\"/></div>\r\n            </div>\r\n            <div className='video_container' id='video_container' hidden>\r\n                <video className=\"video-player\" id='user-1' autoPlay playsInline ></video>\r\n                <video className=\"video-player\" id='user-2' autoPlay playsInline ></video>\r\n            </div>\r\n            <div className={isCalling ? 'visible' : 'hidden'} id='call_request'>\r\n                <div id='call_request_text'>\r\n                    {string} is calling you!\r\n                </div>\r\n                <div id='call_request_controls'>\r\n                    <div className='control-container' id='call_request_accept_call'>\r\n                        <img src={PhoneIcon} alt='accept_call' />\r\n                    </div>\r\n                    <div className='control-container' id='leave_btn' onClick={deny_call}>\r\n                        <img src={EndCall} alt='deny_call'/>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div className={isVisible ? 'visible' : 'hidden'} id='call_controls'>\r\n                <div className=\"control-container\" id=\"camera_btn\" onClick={toggle_camera}>\r\n                    <img src={CameraIcon} alt='camera_btn' />\r\n                </div>\r\n                <div className=\"control-container\" id=\"mic_btn\" onClick={toggle_audio}>\r\n                    <img src={MicIcon} alt='microphone_btn' />\r\n                </div>\r\n                <div className=\"control-container\" id=\"leave_btn\" onClick={handleUserLeft}>\r\n                    <img src={PhoneIcon} alt='leave_btn' />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ConControls",{"ruleId":"155","severity":1,"message":"156","line":2,"column":8,"nodeType":"157","messageId":"158","endLine":2,"endColumn":14},{"ruleId":"155","severity":1,"message":"159","line":3,"column":8,"nodeType":"157","messageId":"158","endLine":3,"endColumn":19},{"ruleId":"155","severity":1,"message":"160","line":6,"column":14,"nodeType":"157","messageId":"158","endLine":6,"endColumn":24},{"ruleId":"161","severity":1,"message":"162","line":10,"column":9,"nodeType":"163","endLine":10,"endColumn":12},{"ruleId":"164","severity":1,"message":"165","line":141,"column":8,"nodeType":"166","endLine":141,"endColumn":39,"suggestions":"167"},{"ruleId":"155","severity":1,"message":"168","line":1,"column":16,"nodeType":"157","messageId":"158","endLine":1,"endColumn":24},{"ruleId":"155","severity":1,"message":"169","line":1,"column":26,"nodeType":"157","messageId":"158","endLine":1,"endColumn":35},{"ruleId":"155","severity":1,"message":"170","line":1,"column":37,"nodeType":"157","messageId":"158","endLine":1,"endColumn":47},{"ruleId":"155","severity":1,"message":"159","line":2,"column":8,"nodeType":"157","messageId":"158","endLine":2,"endColumn":19},{"ruleId":"155","severity":1,"message":"171","line":3,"column":8,"nodeType":"157","messageId":"158","endLine":3,"endColumn":21},{"ruleId":"155","severity":1,"message":"172","line":17,"column":15,"nodeType":"157","messageId":"158","endLine":17,"endColumn":28},{"ruleId":"173","severity":1,"message":"174","line":50,"column":28,"nodeType":"175","messageId":"176","endLine":50,"endColumn":30},{"ruleId":"173","severity":1,"message":"177","line":69,"column":24,"nodeType":"175","messageId":"176","endLine":69,"endColumn":26},{"ruleId":"173","severity":1,"message":"177","line":77,"column":24,"nodeType":"175","messageId":"176","endLine":77,"endColumn":26},{"ruleId":"155","severity":1,"message":"178","line":4,"column":8,"nodeType":"157","messageId":"158","endLine":4,"endColumn":21},{"ruleId":"155","severity":1,"message":"168","line":1,"column":28,"nodeType":"157","messageId":"158","endLine":1,"endColumn":36},{"ruleId":"155","severity":1,"message":"169","line":1,"column":38,"nodeType":"157","messageId":"158","endLine":1,"endColumn":47},{"ruleId":"155","severity":1,"message":"159","line":7,"column":8,"nodeType":"157","messageId":"158","endLine":7,"endColumn":19},{"ruleId":"164","severity":1,"message":"179","line":49,"column":8,"nodeType":"166","endLine":49,"endColumn":10,"suggestions":"180"},{"ruleId":"155","severity":1,"message":"168","line":1,"column":16,"nodeType":"157","messageId":"158","endLine":1,"endColumn":24},{"ruleId":"155","severity":1,"message":"169","line":1,"column":26,"nodeType":"157","messageId":"158","endLine":1,"endColumn":35},{"ruleId":"155","severity":1,"message":"181","line":5,"column":7,"nodeType":"157","messageId":"158","endLine":5,"endColumn":24},{"ruleId":"164","severity":1,"message":"182","line":49,"column":10,"nodeType":"166","endLine":49,"endColumn":12,"suggestions":"183"},{"ruleId":"155","severity":1,"message":"184","line":1,"column":49,"nodeType":"157","messageId":"158","endLine":1,"endColumn":57},{"ruleId":"155","severity":1,"message":"185","line":35,"column":9,"nodeType":"157","messageId":"158","endLine":35,"endColumn":17},{"ruleId":"155","severity":1,"message":"185","line":50,"column":9,"nodeType":"157","messageId":"158","endLine":50,"endColumn":17},{"ruleId":"164","severity":1,"message":"182","line":62,"column":6,"nodeType":"166","endLine":62,"endColumn":8,"suggestions":"186"},{"ruleId":"155","severity":1,"message":"169","line":1,"column":26,"nodeType":"157","messageId":"158","endLine":1,"endColumn":35},{"ruleId":"173","severity":1,"message":"177","line":57,"column":53,"nodeType":"175","messageId":"176","endLine":57,"endColumn":55},{"ruleId":"164","severity":1,"message":"187","line":92,"column":22,"nodeType":"157","endLine":92,"endColumn":29},{"ruleId":"164","severity":1,"message":"188","line":96,"column":6,"nodeType":"166","endLine":96,"endColumn":16,"suggestions":"189"},{"ruleId":"173","severity":1,"message":"174","line":117,"column":53,"nodeType":"175","messageId":"176","endLine":117,"endColumn":55},{"ruleId":"173","severity":1,"message":"177","line":187,"column":14,"nodeType":"175","messageId":"176","endLine":187,"endColumn":16},{"ruleId":"173","severity":1,"message":"177","line":191,"column":19,"nodeType":"175","messageId":"176","endLine":191,"endColumn":21},{"ruleId":"155","severity":1,"message":"168","line":1,"column":39,"nodeType":"157","messageId":"158","endLine":1,"endColumn":47},{"ruleId":"155","severity":1,"message":"190","line":26,"column":22,"nodeType":"157","messageId":"158","endLine":26,"endColumn":31},{"ruleId":"155","severity":1,"message":"191","line":26,"column":33,"nodeType":"157","messageId":"158","endLine":26,"endColumn":37},{"ruleId":"155","severity":1,"message":"192","line":55,"column":13,"nodeType":"157","messageId":"158","endLine":55,"endColumn":17},{"ruleId":"173","severity":1,"message":"177","line":213,"column":27,"nodeType":"175","messageId":"176","endLine":213,"endColumn":29},{"ruleId":"173","severity":1,"message":"177","line":213,"column":57,"nodeType":"175","messageId":"176","endLine":213,"endColumn":59},{"ruleId":"173","severity":1,"message":"177","line":224,"column":63,"nodeType":"175","messageId":"176","endLine":224,"endColumn":65},{"ruleId":"173","severity":1,"message":"177","line":232,"column":27,"nodeType":"175","messageId":"176","endLine":232,"endColumn":29},{"ruleId":"173","severity":1,"message":"177","line":232,"column":57,"nodeType":"175","messageId":"176","endLine":232,"endColumn":59},{"ruleId":"173","severity":1,"message":"177","line":251,"column":27,"nodeType":"175","messageId":"176","endLine":251,"endColumn":29},{"ruleId":"173","severity":1,"message":"177","line":251,"column":70,"nodeType":"175","messageId":"176","endLine":251,"endColumn":72},{"ruleId":"164","severity":1,"message":"193","line":423,"column":8,"nodeType":"166","endLine":423,"endColumn":10,"suggestions":"194"},"no-unused-vars","'Header' is defined but never used.","Identifier","unusedVar","'AuthContext' is defined but never used.","'logoutUser' is assigned a value but never used.","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/anchor-is-valid.md","JSXOpeningElement","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'updateToken'. Either include it or remove the dependency array.","ArrayExpression",["195"],"'useState' is defined but never used.","'useEffect' is defined but never used.","'useContext' is defined but never used.","'FriendContext' is defined but never used.","'passwordError' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'MainContainer' is defined but never used.","React Hook useEffect has a missing dependency: 'getFriends'. Either include it or remove the dependency array.",["196"],"'FriendListContext' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'getFriendRequest'. Either include it or remove the dependency array.",["197"],"'Navigate' is defined but never used.","'response' is assigned a value but never used.",["198"],"The ref value 'containerRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'containerRef.current' to a variable inside the effect, and use that variable in the cleanup function.","React Hook useEffect has missing dependencies: 'getMessages', 'removeFromStorage', 'string', and 'updates'. Either include them or remove the dependency array.",["199"],"'authToken' is assigned a value but never used.","'user' is assigned a value but never used.","'chat' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'handleUserLeft'. Either include it or remove the dependency array.",["200"],{"desc":"201","fix":"202"},{"desc":"203","fix":"204"},{"desc":"205","fix":"206"},{"desc":"205","fix":"207"},{"desc":"208","fix":"209"},{"desc":"210","fix":"211"},"Update the dependencies array to be: [authToken, loading, WebSocket, updateToken]",{"range":"212","text":"213"},"Update the dependencies array to be: [getFriends]",{"range":"214","text":"215"},"Update the dependencies array to be: [getFriendRequest]",{"range":"216","text":"217"},{"range":"218","text":"217"},"Update the dependencies array to be: [getMessages, removeFromStorage, string, updates, username]",{"range":"219","text":"220"},"Update the dependencies array to be: [handleUserLeft]",{"range":"221","text":"222"},[4943,4974],"[authToken, loading, WebSocket, updateToken]",[1477,1479],"[getFriends]",[1529,1531],"[getFriendRequest]",[1962,1964],[3144,3154],"[getMessages, removeFromStorage, string, updates, username]",[14977,14979],"[handleUserLeft]"]